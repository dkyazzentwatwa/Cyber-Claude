import { Command } from 'commander';
import { ui } from '../../utils/ui.js';
import { CyberAgent } from '../../agent/core.js';
import { WebScanner } from '../../agent/tools/web/WebScanner.js';
import { config, validateConfig } from '../../utils/config.js';
import { getModelByKey } from '../../utils/models.js';
import { promises as fs } from 'fs';
import * as path from 'path';
import { WebScanResult } from '../../agent/types.js';
import { NucleiMCP, SSLScanMCP, SQLmapMCP } from '../../mcp/tools/index.js';

/**
 * Save scan results to the /scans directory as markdown
 */
async function saveScanResults(result: WebScanResult, analysis?: string): Promise<string> {
  // Create scans directory if it doesn't exist
  const scansDir = path.join(process.cwd(), 'scans');
  await fs.mkdir(scansDir, { recursive: true });

  // Generate filename from hostname and timestamp
  const hostname = result.target.hostname.replace(/[^a-zA-Z0-9.-]/g, '_');
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const filename = `${hostname}_${timestamp}.md`;
  const filepath = path.join(scansDir, filename);

  // Format markdown content
  const markdown = formatScanMarkdown(result, analysis);

  // Write to file
  await fs.writeFile(filepath, markdown, 'utf-8');

  return filepath;
}

/**
 * Format scan results as markdown
 */
function formatScanMarkdown(result: WebScanResult, analysis?: string): string {
  const lines: string[] = [];

  // Header
  lines.push(`# Web Security Scan Report`);
  lines.push(`\n**Target:** ${result.target.url}`);
  lines.push(`**Scan Date:** ${new Date(result.scanTime).toLocaleString()}`);
  lines.push(`**Duration:** ${result.duration}ms`);
  lines.push(`**Protocol:** ${result.target.protocol.toUpperCase()}`);
  if (result.technology?.server) {
    lines.push(`**Server:** ${result.technology.server}`);
  }
  lines.push('');

  // Summary
  lines.push(`## Summary`);
  lines.push('');
  lines.push(`| Severity | Count |`);
  lines.push(`|----------|-------|`);
  lines.push(`| 🔴 Critical | ${result.summary.critical} |`);
  lines.push(`| 🟠 High | ${result.summary.high} |`);
  lines.push(`| 🟡 Medium | ${result.summary.medium} |`);
  lines.push(`| 🟢 Low | ${result.summary.low} |`);
  lines.push(`| 🔵 Info | ${result.summary.info} |`);
  lines.push(`| **Total** | **${result.summary.total}** |`);
  lines.push('');

  // Findings
  if (result.findings.length > 0) {
    lines.push(`## Findings`);
    lines.push('');

    // Group by severity
    const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
    for (const severity of severityOrder) {
      const findings = result.findings.filter(f => f.severity === severity);
      if (findings.length === 0) continue;

      const emoji = {
        critical: '🔴',
        high: '🟠',
        medium: '🟡',
        low: '🟢',
        info: '🔵'
      }[severity];

      lines.push(`### ${emoji} ${severity.toUpperCase()}`);
      lines.push('');

      findings.forEach((finding, index) => {
        lines.push(`#### ${index + 1}. ${finding.title}`);
        lines.push('');
        lines.push(`**Description:** ${finding.description}`);
        lines.push('');
        if (finding.remediation) {
          lines.push(`**Remediation:** ${finding.remediation}`);
          lines.push('');
        }
        if (finding.references && finding.references.length > 0) {
          lines.push(`**References:**`);
          finding.references.forEach(ref => {
            lines.push(`- ${ref}`);
          });
          lines.push('');
        }
        lines.push(`**Category:** ${finding.category}`);
        lines.push('');
        lines.push('---');
        lines.push('');
      });
    }
  } else {
    lines.push(`## Findings`);
    lines.push('');
    lines.push(`✅ No security issues found!`);
    lines.push('');
  }

  // AI Analysis
  if (analysis) {
    lines.push(`## AI Security Analysis`);
    lines.push('');
    lines.push(analysis);
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(`*Report generated by Cyber Claude on ${new Date().toLocaleString()}*`);

  return lines.join('\n');
}

export function createWebScanCommand(): Command {
  const command = new Command('webscan');

  command
    .description('Scan web applications for security vulnerabilities')
    .argument('<url>', 'Target URL to scan')
    .option('-q, --quick', 'Quick security scan (headers only)')
    .option('-f, --full', 'Full vulnerability scan')
    .option('--ctf', 'CTF challenge mode')
    .option('--skip-auth', 'Skip authorization checks (use only for sites you own)')
    .option('--model <model>', 'AI model to use for analysis')
    .option('--timeout <ms>', 'Request timeout in milliseconds', '10000')
    .option('--nuclei', 'Run Nuclei vulnerability scan (5000+ templates)')
    .option('--sslscan', 'Run SSL/TLS security analysis')
    .option('--sqlmap', 'Test for SQL injection vulnerabilities')
    .option('--with-mcp', 'Run all available MCP security tools')
    .action(async (url: string, options) => {
      const validation = validateConfig();
      if (!validation.valid) {
        ui.error('Configuration Error:');
        validation.errors.forEach(err => ui.error(`  ${err}`));
        process.exit(1);
      }

      // Get model
      let modelId = config.model;
      if (options.model) {
        const modelConfig = getModelByKey(options.model);
        if (!modelConfig) {
          ui.error(`Invalid model: ${options.model}`);
          process.exit(1);
        }
        modelId = modelConfig.id;
      }

      const scanner = new WebScanner();

      try {
        console.log('');
        ui.section(`Web Security Scan: ${url}`);
        console.log('');

        // Progress callback
        const onProgress = (message: string) => {
          console.log(message);
        };

        // Perform scan based on options
        let result;
        if (options.full) {
          result = await scanner.fullScan(url, {
            timeout: parseInt(options.timeout),
            ctfMode: options.ctf,
            skipAuth: options.skipAuth,
            onProgress,
          });
          ui.success('✓ Full scan completed\n');
        } else {
          result = await scanner.quickScan(url, {
            timeout: parseInt(options.timeout),
            ctfMode: options.ctf,
            skipAuth: options.skipAuth,
            onProgress,
          });
          ui.success('✓ Quick scan completed\n');
        }

        // Display results
        console.log('');
        ui.section('Scan Results');
        console.log(`Target: ${result.target.url}`);
        console.log(`Protocol: ${result.target.protocol.toUpperCase()}`);
        if (result.technology?.server) {
          console.log(`Server: ${result.technology.server}`);
        }
        console.log('');

        // Display findings summary
        console.log('Findings Summary:');
        console.log(`  Total: ${result.summary.total}`);
        console.log(`  🔴 Critical: ${result.summary.critical}`);
        console.log(`  🟠 High: ${result.summary.high}`);
        console.log(`  🟡 Medium: ${result.summary.medium}`);
        console.log(`  🟢 Low: ${result.summary.low}`);
        console.log(`  🔵 Info: ${result.summary.info}`);
        console.log('');

        // Display findings
        if (result.findings.length > 0) {
          result.findings.slice(0, 10).forEach(finding => {
            ui.finding(finding.severity, finding.title, finding.description);
          });

          if (result.findings.length > 10) {
            console.log(`\n... and ${result.findings.length - 10} more findings`);
          }
        } else {
          ui.success('No security issues found!');
        }

        // MCP Security Tool Scans
        const mcpFindings: any[] = [];
        const enableAllMCP = options.withMcp;

        // Nuclei Vulnerability Scan
        if (options.nuclei || enableAllMCP) {
          if (NucleiMCP.isAvailable()) {
            console.log('');
            ui.section('🔍 Nuclei Vulnerability Scan');
            const nucleiSpinner = ui.spinner('Running Nuclei scan with 5000+ templates...').start();

            try {
              const nucleiResult = await NucleiMCP.scan({
                target: url,
                templates: ['cves', 'owasp', 'vulnerabilities'],
                severity: ['critical', 'high', 'medium'],
              });

              nucleiSpinner.succeed(`Nuclei scan complete`);

              console.log(`\nFound ${nucleiResult.summary.total} vulnerabilities:`);
              console.log(`  🔴 Critical: ${nucleiResult.summary.critical}`);
              console.log(`  🟠 High: ${nucleiResult.summary.high}`);
              console.log(`  🟡 Medium: ${nucleiResult.summary.medium}`);

              if (nucleiResult.vulnerabilities.length > 0) {
                console.log('\nTop Vulnerabilities:');
                nucleiResult.vulnerabilities.slice(0, 5).forEach((vuln, idx) => {
                  console.log(`  ${idx + 1}. [${vuln.severity.toUpperCase()}] ${vuln.name}`);
                  console.log(`     Template: ${vuln.templateID}`);
                });
              }

              mcpFindings.push({ tool: 'Nuclei', result: nucleiResult });
            } catch (error: any) {
              nucleiSpinner.fail(`Nuclei scan failed: ${error.message}`);
            }
          } else {
            ui.warning('Nuclei MCP not enabled. Set MCP_NUCLEI_ENABLED=true');
          }
        }

        // SSL/TLS Security Analysis
        const parsedUrl = new URL(url);
        if ((options.sslscan || enableAllMCP) && parsedUrl.protocol === 'https:') {
          if (SSLScanMCP.isAvailable()) {
            console.log('');
            ui.section('🔒 SSL/TLS Security Analysis');
            const sslSpinner = ui.spinner('Analyzing SSL/TLS configuration...').start();

            try {
              const sslResult = await SSLScanMCP.scan({
                host: parsedUrl.hostname,
                port: 443,
              });

              sslSpinner.succeed('SSL/TLS analysis complete');

              console.log(`\nSecurity Grade: ${sslResult.grade} (Score: ${sslResult.score}/100)`);
              console.log(`Supported Protocols: ${sslResult.supportedProtocols.join(', ')}`);

              if (sslResult.deprecatedProtocols.length > 0) {
                console.log(`⚠️  Deprecated Protocols: ${sslResult.deprecatedProtocols.join(', ')}`);
              }

              if (sslResult.vulnerabilities.length > 0) {
                console.log(`\nSSL/TLS Vulnerabilities Found:`);
                sslResult.vulnerabilities.forEach(vuln => {
                  console.log(`  🔴 ${vuln.name} (${vuln.severity}): ${vuln.description}`);
                });
              }

              if (sslResult.certificate) {
                console.log(`\nCertificate:`);
                console.log(`  Subject: ${sslResult.certificate.subject}`);
                console.log(`  Issuer: ${sslResult.certificate.issuer}`);
                console.log(`  Expires: ${sslResult.certificate.validTo} (${sslResult.certificate.daysUntilExpiry} days)`);
              }

              mcpFindings.push({ tool: 'SSLScan', result: sslResult });
            } catch (error: any) {
              sslSpinner.fail(`SSL/TLS scan failed: ${error.message}`);
            }
          } else {
            ui.warning('SSLScan MCP not enabled. Set MCP_SSLSCAN_ENABLED=true');
          }
        }

        // SQL Injection Testing
        if (options.sqlmap || enableAllMCP) {
          if (SQLmapMCP.isAvailable()) {
            console.log('');
            ui.section('💉 SQL Injection Testing');
            const sqlSpinner = ui.spinner('Testing for SQL injection vulnerabilities...').start();

            try {
              const sqlResult = await SQLmapMCP.scan({
                url,
                level: 2,
                risk: 1,
                timeout: 120,
              });

              sqlSpinner.succeed('SQL injection test complete');

              if (sqlResult.vulnerable) {
                console.log(`\n🚨 SQL INJECTION DETECTED - Severity: ${sqlResult.severity.toUpperCase()}`);
                console.log(`Found ${sqlResult.injections.length} injection point(s):\n`);

                sqlResult.injections.forEach((inj, idx) => {
                  console.log(`  ${idx + 1}. Parameter: ${inj.parameter}`);
                  console.log(`     Type: ${inj.type}`);
                  console.log(`     DBMS: ${inj.dbms}`);
                });

                if (sqlResult.recommendations.length > 0) {
                  console.log(`\nRecommendations:`);
                  sqlResult.recommendations.slice(0, 3).forEach(rec => {
                    console.log(`  • ${rec}`);
                  });
                }
              } else {
                console.log('\n✓ No SQL injection vulnerabilities detected');
              }

              mcpFindings.push({ tool: 'SQLmap', result: sqlResult });
            } catch (error: any) {
              sqlSpinner.fail(`SQL injection test failed: ${error.message}`);
            }
          } else {
            ui.warning('SQLmap MCP not enabled. Set MCP_SQLMAP_ENABLED=true');
          }
        }

        // AI Analysis
        let analysis: string | undefined;
        if (result.findings.length > 0 || mcpFindings.length > 0) {
          const agent = new CyberAgent({
            mode: 'webpentest',
            apiKey: config.anthropicApiKey,
            googleApiKey: config.googleApiKey,
            model: modelId,
          });

          const spinner = ui.spinner('🤖 Analyzing findings with AI...');

          // Combine all findings for AI analysis
          const analysisData = {
            builtInFindings: result.findings,
            mcpFindings: mcpFindings,
            target: result.target,
          };

          analysis = await agent.analyze(
            'Analyze these comprehensive web security findings from multiple tools (built-in scanner + MCP security tools). Prioritize the issues, explain their impact, provide actionable remediation guidance, and identify any patterns or relationships between findings from different tools. Focus on the most critical vulnerabilities first.',
            analysisData
          );
          spinner.succeed('✓ AI analysis complete');

          console.log('\n' + ui.formatAIResponse(analysis) + '\n');
        }

        // Save scan results
        const savedPath = await saveScanResults(result, analysis);
        ui.success(`📁 Scan results saved to: ${savedPath}`);

      } catch (error: any) {
        ui.error(`Web scan failed: ${error.message}`);
        process.exit(1);
      }
    });

  return command;
}
import { Command } from 'commander';
import { ui } from '../../utils/ui.js';
import { CyberAgent } from '../../agent/core.js';
import { WebScanner } from '../../agent/tools/web/WebScanner.js';
import { config, validateConfig } from '../../utils/config.js';
import { getModelByKey } from '../../utils/models.js';
import { promises as fs } from 'fs';
import * as path from 'path';
import { WebScanResult } from '../../agent/types.js';
// MCP tools removed - no working packages found

/**
 * Save scan results to the /scans directory as markdown
 */
async function saveScanResults(result: WebScanResult, analysis?: string): Promise<string> {
  // Create scans directory if it doesn't exist
  const scansDir = path.join(process.cwd(), 'scans');
  await fs.mkdir(scansDir, { recursive: true });

  // Generate filename from hostname and timestamp
  const hostname = result.target.hostname.replace(/[^a-zA-Z0-9.-]/g, '_');
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const filename = `${hostname}_${timestamp}.md`;
  const filepath = path.join(scansDir, filename);

  // Format markdown content
  const markdown = formatScanMarkdown(result, analysis);

  // Write to file
  await fs.writeFile(filepath, markdown, 'utf-8');

  return filepath;
}

/**
 * Format scan results as markdown
 */
function formatScanMarkdown(result: WebScanResult, analysis?: string): string {
  const lines: string[] = [];

  // Header
  lines.push(`# Web Security Scan Report`);
  lines.push(`\n**Target:** ${result.target.url}`);
  lines.push(`**Scan Date:** ${new Date(result.scanTime).toLocaleString()}`);
  lines.push(`**Duration:** ${result.duration}ms`);
  lines.push(`**Protocol:** ${result.target.protocol.toUpperCase()}`);
  if (result.technology?.server) {
    lines.push(`**Server:** ${result.technology.server}`);
  }
  lines.push('');

  // Summary
  lines.push(`## Summary`);
  lines.push('');
  lines.push(`| Severity | Count |`);
  lines.push(`|----------|-------|`);
  lines.push(`| üî¥ Critical | ${result.summary.critical} |`);
  lines.push(`| üü† High | ${result.summary.high} |`);
  lines.push(`| üü° Medium | ${result.summary.medium} |`);
  lines.push(`| üü¢ Low | ${result.summary.low} |`);
  lines.push(`| üîµ Info | ${result.summary.info} |`);
  lines.push(`| **Total** | **${result.summary.total}** |`);
  lines.push('');

  // Findings
  if (result.findings.length > 0) {
    lines.push(`## Findings`);
    lines.push('');

    // Group by severity
    const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
    for (const severity of severityOrder) {
      const findings = result.findings.filter(f => f.severity === severity);
      if (findings.length === 0) continue;

      const emoji = {
        critical: 'üî¥',
        high: 'üü†',
        medium: 'üü°',
        low: 'üü¢',
        info: 'üîµ'
      }[severity];

      lines.push(`### ${emoji} ${severity.toUpperCase()}`);
      lines.push('');

      findings.forEach((finding, index) => {
        lines.push(`#### ${index + 1}. ${finding.title}`);
        lines.push('');
        lines.push(`**Description:** ${finding.description}`);
        lines.push('');
        if (finding.remediation) {
          lines.push(`**Remediation:** ${finding.remediation}`);
          lines.push('');
        }
        if (finding.references && finding.references.length > 0) {
          lines.push(`**References:**`);
          finding.references.forEach(ref => {
            lines.push(`- ${ref}`);
          });
          lines.push('');
        }
        lines.push(`**Category:** ${finding.category}`);
        lines.push('');
        lines.push('---');
        lines.push('');
      });
    }
  } else {
    lines.push(`## Findings`);
    lines.push('');
    lines.push(`‚úÖ No security issues found!`);
    lines.push('');
  }

  // AI Analysis
  if (analysis) {
    lines.push(`## AI Security Analysis`);
    lines.push('');
    lines.push(analysis);
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(`*Report generated by Cyber Claude on ${new Date().toLocaleString()}*`);

  return lines.join('\n');
}

export function createWebScanCommand(): Command {
  const command = new Command('webscan');

  command
    .description('Scan web applications for security vulnerabilities')
    .argument('<url>', 'Target URL to scan')
    .option('-q, --quick', 'Quick security scan (headers only)')
    .option('-f, --full', 'Full vulnerability scan')
    .option('--ctf', 'CTF challenge mode')
    .option('--skip-auth', 'Skip authorization checks (use only for sites you own)')
    .option('--model <model>', 'AI model to use for analysis')
    .option('--timeout <ms>', 'Request timeout in milliseconds', '10000')
    .option('--nuclei', 'Run Nuclei vulnerability scan (5000+ templates)')
    .option('--sslscan', 'Run SSL/TLS security analysis')
    .option('--sqlmap', 'Test for SQL injection vulnerabilities')
    .option('--with-mcp', 'Run all available MCP security tools')
    .action(async (url: string, options) => {
      const validation = validateConfig();
      if (!validation.valid) {
        ui.error('Configuration Error:');
        validation.errors.forEach(err => ui.error(`  ${err}`));
        process.exit(1);
      }

      // Get model
      let modelId = config.model;
      if (options.model) {
        const modelConfig = getModelByKey(options.model);
        if (!modelConfig) {
          ui.error(`Invalid model: ${options.model}`);
          process.exit(1);
        }
        modelId = modelConfig.id;
      }

      const scanner = new WebScanner();

      try {
        console.log('');
        ui.section(`Web Security Scan: ${url}`);
        console.log('');

        // Progress callback
        const onProgress = (message: string) => {
          console.log(message);
        };

        // Perform scan based on options
        let result;
        if (options.full) {
          result = await scanner.fullScan(url, {
            timeout: parseInt(options.timeout),
            ctfMode: options.ctf,
            skipAuth: options.skipAuth,
            onProgress,
          });
          ui.success('‚úì Full scan completed\n');
        } else {
          result = await scanner.quickScan(url, {
            timeout: parseInt(options.timeout),
            ctfMode: options.ctf,
            skipAuth: options.skipAuth,
            onProgress,
          });
          ui.success('‚úì Quick scan completed\n');
        }

        // Display results
        console.log('');
        ui.section('Scan Results');
        console.log(`Target: ${result.target.url}`);
        console.log(`Protocol: ${result.target.protocol.toUpperCase()}`);
        if (result.technology?.server) {
          console.log(`Server: ${result.technology.server}`);
        }
        console.log('');

        // Display findings summary
        console.log('Findings Summary:');
        console.log(`  Total: ${result.summary.total}`);
        console.log(`  üî¥ Critical: ${result.summary.critical}`);
        console.log(`  üü† High: ${result.summary.high}`);
        console.log(`  üü° Medium: ${result.summary.medium}`);
        console.log(`  üü¢ Low: ${result.summary.low}`);
        console.log(`  üîµ Info: ${result.summary.info}`);
        console.log('');

        // Display findings
        if (result.findings.length > 0) {
          result.findings.slice(0, 10).forEach(finding => {
            ui.finding(finding.severity, finding.title, finding.description);
          });

          if (result.findings.length > 10) {
            console.log(`\n... and ${result.findings.length - 10} more findings`);
          }
        } else {
          ui.success('No security issues found!');
        }

        // MCP Security Tool Scans removed - no working MCP packages found

        // AI Analysis
        let analysis: string | undefined;
        if (result.findings.length > 0) {
          const agent = new CyberAgent({
            mode: 'webpentest',
            apiKey: config.anthropicApiKey,
            googleApiKey: config.googleApiKey,
            model: modelId,
          });

          const spinner = ui.spinner('ü§ñ Analyzing findings with AI...');

          // Combine all findings for AI analysis
          const analysisData = {
            builtInFindings: result.findings,
            target: result.target,
          };

          analysis = await agent.analyze(
            'Analyze these web security findings from the built-in scanner. Prioritize the issues, explain their impact, provide actionable remediation guidance. Focus on the most critical vulnerabilities first.',
            analysisData
          );
          spinner.succeed('‚úì AI analysis complete');

          console.log('\n' + ui.formatAIResponse(analysis) + '\n');
        }

        // Save scan results
        const savedPath = await saveScanResults(result, analysis);
        ui.success(`üìÅ Scan results saved to: ${savedPath}`);

      } catch (error: any) {
        ui.error(`Web scan failed: ${error.message}`);
        process.exit(1);
      }
    });

  return command;
}
import inquirer from 'inquirer';
import chalk from 'chalk';
import { ui } from '../utils/ui.js';
import { CyberAgent } from '../agent/core.js';
import { DesktopScanner } from '../agent/tools/scanner.js';
import { HardeningChecker } from '../agent/tools/hardening.js';
import { SecurityReporter } from '../agent/tools/reporter.js';
import { WebScanner } from '../agent/tools/web/WebScanner.js';
import { PcapAnalyzer } from '../agent/tools/PcapAnalyzer.js';
import { PcapReporter } from '../agent/tools/PcapReporter.js';
import { OSINTOrchestrator, OSINTReporter } from '../agent/tools/osint/index.js';
import { WORKFLOWS } from './commands/flows.js';
import { config } from '../utils/config.js';
import { AgentMode, WebScanResult } from '../agent/types.js';
import { AVAILABLE_MODELS, ModelKey, getModelByKey } from '../utils/models.js';
import { promises as fs } from 'fs';
import * as path from 'path';

/**
 * Save scan results to the /scans directory as markdown
 */
async function saveScanResults(result: WebScanResult, analysis?: string): Promise<string> {
  // Create scans directory if it doesn't exist
  const scansDir = path.join(process.cwd(), 'scans');
  await fs.mkdir(scansDir, { recursive: true });

  // Generate filename from hostname and timestamp
  const hostname = result.target.hostname.replace(/[^a-zA-Z0-9.-]/g, '_');
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
  const filename = `${hostname}_${timestamp}.md`;
  const filepath = path.join(scansDir, filename);

  // Format markdown content
  const markdown = formatScanMarkdown(result, analysis);

  // Write to file
  await fs.writeFile(filepath, markdown, 'utf-8');

  return filepath;
}

/**
 * Format scan results as markdown
 */
function formatScanMarkdown(result: WebScanResult, analysis?: string): string {
  const lines: string[] = [];

  // Header
  lines.push(`# Web Security Scan Report`);
  lines.push(`\n**Target:** ${result.target.url}`);
  lines.push(`**Scan Date:** ${new Date(result.scanTime).toLocaleString()}`);
  lines.push(`**Duration:** ${result.duration}ms`);
  lines.push(`**Protocol:** ${result.target.protocol.toUpperCase()}`);
  if (result.technology?.server) {
    lines.push(`**Server:** ${result.technology.server}`);
  }
  lines.push('');

  // Summary
  lines.push(`## Summary`);
  lines.push('');
  lines.push(`| Severity | Count |`);
  lines.push(`|----------|-------|`);
  lines.push(`| üî¥ Critical | ${result.summary.critical} |`);
  lines.push(`| üü† High | ${result.summary.high} |`);
  lines.push(`| üü° Medium | ${result.summary.medium} |`);
  lines.push(`| üü¢ Low | ${result.summary.low} |`);
  lines.push(`| üîµ Info | ${result.summary.info} |`);
  lines.push(`| **Total** | **${result.summary.total}** |`);
  lines.push('');

  // Findings
  if (result.findings.length > 0) {
    lines.push(`## Findings`);
    lines.push('');

    // Group by severity
    const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
    for (const severity of severityOrder) {
      const findings = result.findings.filter(f => f.severity === severity);
      if (findings.length === 0) continue;

      const emoji = {
        critical: 'üî¥',
        high: 'üü†',
        medium: 'üü°',
        low: 'üü¢',
        info: 'üîµ'
      }[severity];

      lines.push(`### ${emoji} ${severity.toUpperCase()}`);
      lines.push('');

      findings.forEach((finding, index) => {
        lines.push(`#### ${index + 1}. ${finding.title}`);
        lines.push('');
        lines.push(`**Description:** ${finding.description}`);
        lines.push('');
        if (finding.remediation) {
          lines.push(`**Remediation:** ${finding.remediation}`);
          lines.push('');
        }
        if (finding.references && finding.references.length > 0) {
          lines.push(`**References:**`);
          finding.references.forEach(ref => {
            lines.push(`- ${ref}`);
          });
          lines.push('');
        }
        lines.push(`**Category:** ${finding.category}`);
        lines.push('');
        lines.push('---');
        lines.push('');
      });
    }
  } else {
    lines.push(`## Findings`);
    lines.push('');
    lines.push(`‚úÖ No security issues found!`);
    lines.push('');
  }

  // AI Analysis
  if (analysis) {
    lines.push(`## AI Security Analysis`);
    lines.push('');
    lines.push(analysis);
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('');
  lines.push(`*Report generated by Cyber Claude on ${new Date().toLocaleString()}*`);

  return lines.join('\n');
}

interface SessionState {
  agent: CyberAgent;
  mode: AgentMode;
  model: string;
  commandHistory: string[];
}

export class InteractiveSession {
  private state: SessionState;
  private scanner: DesktopScanner;
  private hardening: HardeningChecker;
  private reporter: SecurityReporter;
  private webScanner: WebScanner;
  private pcapAnalyzer: PcapAnalyzer;
  private pcapReporter: PcapReporter;
  private osintOrchestrator: OSINTOrchestrator;
  private osintReporter: OSINTReporter;

  constructor(initialMode: AgentMode = 'base', model?: string) {
    this.scanner = new DesktopScanner();
    this.hardening = new HardeningChecker();
    this.reporter = new SecurityReporter();
    this.webScanner = new WebScanner();
    this.pcapAnalyzer = new PcapAnalyzer();
    this.pcapReporter = new PcapReporter();
    this.osintOrchestrator = new OSINTOrchestrator();
    this.osintReporter = new OSINTReporter();

    const selectedModel = model || config.model;

    this.state = {
      agent: new CyberAgent({
        mode: initialMode,
        apiKey: config.anthropicApiKey,
        googleApiKey: config.googleApiKey,
        model: selectedModel,
      }),
      mode: initialMode,
      model: selectedModel,
      commandHistory: [],
    };
  }

  /**
   * Start the interactive session
   */
  async start(): Promise<void> {
    ui.clear();
    ui.banner();
    this.showModeStatus();
    this.showWelcome();

    // Main session loop
    while (true) {
      try {
        const prompt = this.getPrompt();
        const { command } = await inquirer.prompt({
          type: 'input',
          name: 'command',
          message: prompt,
          prefix: '',
        } as any);

        if (!command || command.trim() === '') {
          continue;
        }

        const trimmedCommand = command.trim();
        this.state.commandHistory.push(trimmedCommand);

        // Handle commands
        const shouldExit = await this.handleCommand(trimmedCommand);
        if (shouldExit) {
          break;
        }
      } catch (error) {
        // User pressed Ctrl+C or error occurred
        console.log('\n');
        ui.info('Exiting session...');
        break;
      }
    }
  }

  private getPrompt(): string {
    const modeIcons = {
      base: 'ü§ñ',
      redteam: '‚öîÔ∏è',
      blueteam: 'üõ°Ô∏è',
      desktopsecurity: 'üîí',
      webpentest: 'üåê',
      osint: 'üîç',
    };

    const icon = modeIcons[this.state.mode];
    const text = `${icon} [${this.state.mode}] >`;

    // Apply color based on mode
    switch (this.state.mode) {
      case 'redteam':
        return chalk.red(text);
      case 'blueteam':
        return chalk.blue(text);
      case 'desktopsecurity':
        return chalk.green(text);
      case 'webpentest':
        return chalk.magenta(text);
      case 'osint':
        return chalk.yellow(text);
      default:
        return chalk.cyan(text);
    }
  }

  private showModeStatus(): void {
    const modelInfo = Object.values(AVAILABLE_MODELS).find(m => m.id === this.state.model);
    const modelName = modelInfo?.name || this.state.model;

    console.log(chalk.dim(`Mode: ${chalk.bold(this.state.mode)} | Model: ${chalk.bold(modelName)}\n`));
  }

  private showWelcome(): void {
    ui.box(
      `Welcome to ${chalk.bold('Cyber Claude Interactive Session')}! ${chalk.green('v0.6.0')}\n\n` +
      `${chalk.bold('üöÄ Quick Start Guide:')}\n\n` +
      `${chalk.bold('1. Scan Your System:')}\n` +
      `   ${chalk.cyan('scan')} ${chalk.dim('- Quick security check')}\n` +
      `   ${chalk.cyan('scan full')} ${chalk.dim('- Comprehensive scan with AI analysis')}\n\n` +
      `${chalk.bold('2. Test Websites:')}\n` +
      `   ${chalk.cyan('webscan https://example.com')} ${chalk.dim('- Find vulnerabilities')}\n` +
      `   ${chalk.cyan('webscan https://test.local --aggressive')} ${chalk.green('(NEW!)')} ${chalk.dim('- Active payload testing')}\n\n` +
      `${chalk.bold('3. Analyze Logs:')}\n` +
      `   ${chalk.cyan('logs /var/log/auth.log')} ${chalk.green('(NEW!)')} ${chalk.dim('- AI-powered log analysis')}\n\n` +
      `${chalk.bold('4. CVE Lookup:')}\n` +
      `   ${chalk.cyan('cve CVE-2024-1234')} ${chalk.green('(NEW!)')} ${chalk.dim('- Vulnerability database search')}\n\n` +
      `${chalk.bold('5. Scheduled Scans:')}\n` +
      `   ${chalk.cyan('daemon status')} ${chalk.green('(NEW!)')} ${chalk.dim('- Manage background scanning')}\n\n` +
      `${chalk.bold('6. Gather Intel:')}\n` +
      `   ${chalk.cyan('recon example.com')} ${chalk.dim('- OSINT reconnaissance')}\n\n` +
      `${chalk.bold('7. Get Help:')}\n` +
      `   ${chalk.cyan('help')} ${chalk.dim('- Show detailed command guide with examples')}\n\n` +
      `${chalk.bold('8. Chat Naturally:')}\n` +
      `   ${chalk.dim('Just type: ')}${chalk.cyan('How do I secure SSH?')}${chalk.dim(' or ')}${chalk.cyan('Explain XSS attacks')}\n\n` +
      `${chalk.dim('üí° Tip: Type ')}${chalk.cyan('help')}${chalk.dim(' for detailed examples of every command')}\n` +
      `${chalk.dim('üí° Tip: Change modes with ')}${chalk.cyan('mode <name>')}${chalk.dim(' (base, redteam, blueteam, osint, etc.)')}`,
      'üöÄ Interactive Session',
      'info'
    );
  }

  private async handleCommand(command: string): Promise<boolean> {
    const parts = command.toLowerCase().split(' ');
    const cmd = parts[0];
    const args = parts.slice(1);

    // Check for built-in commands first
    switch (cmd) {
      case 'exit':
      case 'quit':
        ui.info('Goodbye! üëã');
        return true;

      case 'help':
        this.showHelp();
        return false;

      case 'clear':
        this.state.agent.clearHistory();
        ui.success('Conversation history cleared');
        return false;

      case 'status':
        this.showStatus();
        return false;

      case 'history':
        this.showHistory();
        return false;

      case 'mode':
        await this.handleModeChange(args);
        return false;

      case 'model':
        await this.handleModelSelect();
        return false;

      case 'scan':
        await this.handleScan(args);
        return false;

      case 'webscan':
        await this.handleWebScan(args);
        return false;

      case 'pcap':
        await this.handlePcap(args);
        return false;

      case 'recon':
        await this.handleRecon(args);
        return false;

      case 'harden':
        await this.handleHarden();
        return false;

      case 'flows':
        await this.handleFlows();
        return false;

      case 'auto':
        await this.handleAuto(command);
        return false;

      case 'cve':
        await this.handleCVE(args);
        return false;

      case 'logs':
        await this.handleLogs(args);
        return false;

      case 'daemon':
        await this.handleDaemon(args);
        return false;

      default:
        // If not a built-in command, send to agent as chat
        await this.handleChat(command);
        return false;
    }
  }

  private showHelp(): void {
    console.log('\n' + chalk.bold.cyan('‚ïê'.repeat(80)));
    console.log(chalk.bold.cyan('                           CYBER CLAUDE - HELP GUIDE'));
    console.log(chalk.bold.cyan('‚ïê'.repeat(80)) + '\n');

    // SCANNING COMMANDS
    console.log(chalk.bold.cyan('üìä SCANNING & ANALYSIS COMMANDS\n'));

    console.log(chalk.bold('  scan') + chalk.dim(' - Quick security check of your system'));
    console.log(chalk.dim('    Checks: OS info, running processes, open ports, disk usage'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('scan') + '\n');

    console.log(chalk.bold('  scan full') + chalk.dim(' - Comprehensive system security scan with AI analysis'));
    console.log(chalk.dim('    Analyzes: Everything in quick scan + detailed vulnerability assessment'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('scan full') + '\n');

    console.log(chalk.bold('  scan network') + chalk.dim(' - Analyze active network connections'));
    console.log(chalk.dim('    Shows: Active connections, listening ports, suspicious traffic'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('scan network') + '\n');

    console.log(chalk.bold('  webscan <url>') + chalk.dim(' - Test web application security'));
    console.log(chalk.dim('    Tests: Headers, CSRF, cookies, OWASP Top 10 vulnerabilities'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('webscan https://example.com'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('webscan http://localhost:3000') + '\n');

    console.log(chalk.bold('  recon <target>') + chalk.dim(' - OSINT reconnaissance (passive intelligence gathering)'));
    console.log(chalk.dim('    Gathers: DNS, WHOIS, subdomains, emails, breaches, social media'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('recon example.com') + chalk.dim(' (domain scan)'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('recon johndoe') + chalk.dim(' (username search)'));
    console.log(chalk.yellow('    Options: ') + chalk.dim('--quick (fast), --full (comprehensive), --domain, --person') + '\n');

    console.log(chalk.bold('  pcap <file>') + chalk.dim(' - Analyze network capture files (Wireshark format)'));
    console.log(chalk.dim('    Analyzes: Packets, protocols, conversations, DNS, HTTP, anomalies'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('pcap capture.pcap'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('pcap /path/to/traffic.pcapng') + '\n');

    console.log(chalk.bold('  harden') + chalk.dim(' - Check system hardening and security posture'));
    console.log(chalk.dim('    Checks: Firewall, disk encryption, antivirus, security settings'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('harden') + '\n');

    console.log(chalk.bold('  flows') + chalk.dim(' - Pre-configured workflows for common tasks') + chalk.green(' (Beginner-friendly)'));
    console.log(chalk.dim('    Includes: Quick security check, web audits, OSINT, incident response, CTF, tutorials'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('flows') + '\n');

    console.log(chalk.bold('  auto <task>') + chalk.dim(' - Autonomous task execution with AI planning') + chalk.green(' (NEW!)'));
    console.log(chalk.dim('    AI breaks down tasks into steps and executes autonomously'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('auto scan example.com for vulnerabilities'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('auto gather intel on target-company.com'));
    console.log(chalk.dim('    Options: --mode <mode>, --verbose, --export <file>') + '\n');

    console.log(chalk.bold('  logs <file>') + chalk.dim(' - Analyze security logs with AI') + chalk.green(' (NEW v0.6.0)'));
    console.log(chalk.dim('    Analyzes: syslog, apache, auth, json, windows, firewall formats'));
    console.log(chalk.dim('    Detects: 15+ anomaly types, brute force, SQL injection, port scans'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('logs /var/log/auth.log'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('logs access.log') + '\n');

    console.log(chalk.bold('  cve <cve-id|keyword>') + chalk.dim(' - Search CVE vulnerability database') + chalk.green(' (NEW v0.6.0)'));
    console.log(chalk.dim('    Searches: National Vulnerability Database (NVD) with AI analysis'));
    console.log(chalk.dim('    Shows: CVSS scores, severity, affected versions, remediation'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('cve CVE-2024-1234'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('cve apache') + '\n');

    console.log(chalk.bold('  daemon <subcommand>') + chalk.dim(' - Manage scheduled security scans') + chalk.green(' (NEW v0.6.0)'));
    console.log(chalk.dim('    Subcommands: start, stop, status, jobs, add, remove, enable, disable, run'));
    console.log(chalk.dim('    Schedule scans to run automatically with cron expressions'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('daemon status'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('daemon jobs') + '\n');

    // SESSION CONTROL
    console.log(chalk.bold.cyan('‚öôÔ∏è  SESSION CONTROL\n'));

    console.log(chalk.bold('  mode <mode>') + chalk.dim(' - Switch the AI agent\'s focus and expertise'));
    console.log(chalk.dim('    Available modes (see Agent Modes below for details)'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('mode webpentest'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('mode osint') + '\n');

    console.log(chalk.bold('  model') + chalk.dim(' - Select which AI model to use (Claude or Gemini)'));
    console.log(chalk.dim('    Opens interactive menu to choose from available models'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('model') + '\n');

    console.log(chalk.bold('  status') + chalk.dim(' - Show current session information'));
    console.log(chalk.dim('    Shows: Current mode, model, command count, conversation length'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('status') + '\n');

    console.log(chalk.bold('  clear') + chalk.dim(' - Clear conversation history (fresh start)'));
    console.log(chalk.dim('    Resets the AI\'s memory of previous messages in this session'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('clear') + '\n');

    console.log(chalk.bold('  history') + chalk.dim(' - Show recent commands you\'ve run'));
    console.log(chalk.dim('    Displays last 10 commands from this session'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('history') + '\n');

    // CHAT
    console.log(chalk.bold.cyan('üí¨ CONVERSATIONAL CHAT\n'));
    console.log(chalk.dim('  Just type naturally to ask questions or get advice:'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('How do I secure my SSH server?'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('Explain what a SQL injection is'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('What ports should I close on my firewall?') + '\n');

    // EXIT
    console.log(chalk.bold.cyan('üö™ EXIT SESSION\n'));
    console.log(chalk.bold('  exit') + chalk.dim(' or ') + chalk.bold('quit') + chalk.dim(' - Close the interactive session'));
    console.log(chalk.yellow('    Example: ') + chalk.cyan('exit') + '\n');

    // AGENT MODES
    console.log(chalk.bold.cyan('‚ïê'.repeat(80)));
    console.log(chalk.bold.cyan('üé≠ AGENT MODES - Each mode changes how the AI thinks and responds\n'));

    console.log(chalk.cyan('  base ') + chalk.bold('ü§ñ') + chalk.dim(' - General-purpose security assistant'));
    console.log(chalk.dim('    Use for: General questions, learning, mixed tasks'));
    console.log(chalk.dim('    Best for: Beginners, broad security topics\n'));

    console.log(chalk.red('  redteam ') + chalk.bold('‚öîÔ∏è') + chalk.dim(' - Offensive security mindset (attacker perspective)'));
    console.log(chalk.dim('    Use for: Finding vulnerabilities, attack surface analysis'));
    console.log(chalk.dim('    Best for: Penetration testing, security assessments\n'));

    console.log(chalk.blue('  blueteam ') + chalk.bold('üõ°Ô∏è') + chalk.dim(' - Defensive security focus (defender perspective)'));
    console.log(chalk.dim('    Use for: Threat detection, incident response, monitoring'));
    console.log(chalk.dim('    Best for: SOC analysts, defense strategies\n'));

    console.log(chalk.green('  desktopsecurity ') + chalk.bold('üîí') + chalk.dim(' - Personal computer security'));
    console.log(chalk.dim('    Use for: Protecting your laptop/desktop, privacy, malware'));
    console.log(chalk.dim('    Best for: Personal device security, home users\n'));

    console.log(chalk.magenta('  webpentest ') + chalk.bold('üåê') + chalk.dim(' - Web application security testing'));
    console.log(chalk.dim('    Use for: Testing websites, finding web vulnerabilities, CTFs'));
    console.log(chalk.dim('    Best for: Web developers, bug bounty hunters\n'));

    console.log(chalk.yellow('  osint ') + chalk.bold('üîç') + chalk.dim(' - Open Source Intelligence gathering'));
    console.log(chalk.dim('    Use for: Passive reconnaissance, footprinting, information gathering'));
    console.log(chalk.dim('    Best for: Investigating domains, usernames, digital footprints\n'));

    console.log(chalk.bold.cyan('‚ïê'.repeat(80)));
    console.log(chalk.dim('üí° Tip: Use ') + chalk.cyan('mode <name>') + chalk.dim(' to switch modes based on your task'));
    console.log(chalk.dim('üí° Tip: Commands can be combined with chat - try ') + chalk.cyan('scan') + chalk.dim(' then ask about results'));
    console.log(chalk.bold.cyan('‚ïê'.repeat(80)) + '\n');
  }

  private showStatus(): void {
    const modelInfo = Object.values(AVAILABLE_MODELS).find(m => m.id === this.state.model);

    ui.box(
      `${chalk.bold('Current Mode:')} ${this.state.mode}\n` +
      `${chalk.bold('Model:')} ${modelInfo?.name || this.state.model}\n` +
      `${chalk.bold('Commands Executed:')} ${this.state.commandHistory.length}\n` +
      `${chalk.bold('Conversation Messages:')} ${this.state.agent.getHistory().length}`,
      'üìä Session Status',
      'info'
    );
  }

  private showHistory(): void {
    if (this.state.commandHistory.length === 0) {
      ui.info('No commands in history yet');
      return;
    }

    console.log(chalk.bold('\nüìú Command History:\n'));
    this.state.commandHistory.slice(-10).forEach((cmd, index) => {
      const num = this.state.commandHistory.length - 10 + index + 1;
      console.log(chalk.dim(`  ${num}.`) + ` ${cmd}`);
    });
    console.log('');
  }

  private async handleModeChange(args: string[]): Promise<void> {
    if (args.length === 0) {
      ui.info(`Current mode: ${this.state.mode}`);
      ui.info('Available modes: base, redteam, blueteam, desktopsecurity, webpentest, osint');
      return;
    }

    const newMode = args[0] as AgentMode;
    const validModes = ['base', 'redteam', 'blueteam', 'desktopsecurity', 'webpentest', 'osint'];

    if (validModes.includes(newMode)) {
      this.state.mode = newMode;
      this.state.agent.setMode(newMode);
      ui.success(`Switched to ${chalk.bold(newMode)} mode`);
      this.showModeStatus();
    } else {
      ui.error(`Invalid mode: ${newMode}`);
      ui.info(`Valid modes: ${validModes.join(', ')}`);
    }
  }

  private async handleModelSelect(): Promise<void> {
    const choices = Object.entries(AVAILABLE_MODELS).map(([key, model]) => ({
      name: `${model.name} ${model.recommended ? chalk.green('(Recommended)') : ''}\n  ${chalk.dim(model.description)}`,
      value: key,
      short: model.name,
    }));

    const { selectedModel } = await inquirer.prompt({
      type: 'list',
      name: 'selectedModel',
      message: 'Select AI model:',
      choices,
      default: 'sonnet-4',
    } as any);

    const model = getModelByKey(selectedModel);
    if (model) {
      this.state.model = model.id;
      this.state.agent = new CyberAgent({
        mode: this.state.mode,
        apiKey: config.anthropicApiKey,
        googleApiKey: config.googleApiKey,
        model: model.id,
      });
      ui.success(`Switched to ${chalk.bold(model.name)}`);
      this.showModeStatus();
    }
  }

  private async handleScan(args: string[]): Promise<void> {
    const scanType = args[0] || 'quick';

    try {
      if (scanType === 'full') {
        const spinner = ui.spinner('Performing full system scan...');
        const result = await this.scanner.scanSystem();
        spinner.succeed('System scan completed');

        if (result.success) {
          ui.info('Analyzing with AI...');
          const aiSpinner = ui.spinner('AI analyzing system security...');
          const analysis = await this.state.agent.analyze(
            'Perform a comprehensive security analysis of this system. Identify vulnerabilities, security misconfigurations, and potential risks. Provide specific, actionable recommendations.',
            result.data
          );
          aiSpinner.succeed('Analysis complete');
          console.log('\n' + ui.formatAIResponse(analysis) + '\n');
        }
      } else if (scanType === 'network') {
        const spinner = ui.spinner('Scanning network connections...');
        const result = await this.scanner.scanNetwork();
        spinner.succeed('Network scan completed');

        if (result.success) {
          const aiSpinner = ui.spinner('Analyzing network connections...');
          const analysis = await this.state.agent.analyze(
            'Analyze these network connections for security concerns. Identify any suspicious connections, unusual ports, or potential security risks.',
            result.data
          );
          aiSpinner.succeed('Analysis complete');
          console.log('\n' + ui.formatAIResponse(analysis) + '\n');
        }
      } else {
        // Quick scan
        const spinner = ui.spinner('Running quick security check...');
        const result = await this.scanner.quickCheck();
        spinner.succeed('Quick check completed');

        if (result.success && result.data.findings) {
          const scanResult = this.reporter.createScanResult(result.data.findings, new Date());
          this.reporter.displayReport(scanResult);
        }
      }
    } catch (error) {
      ui.error(`Scan failed: ${error}`);
    }
  }

  private async handleHarden(): Promise<void> {
    try {
      const spinner = ui.spinner('Checking system hardening...');
      const result = await this.hardening.checkHardening();
      spinner.succeed('Hardening check completed');

      if (result.success && result.data.findings) {
        const scanResult = this.reporter.createScanResult(result.data.findings, new Date());
        this.reporter.displayReport(scanResult);

        const aiSpinner = ui.spinner('Getting AI recommendations...');
        const analysis = await this.state.agent.analyze(
          'Based on these hardening check findings, provide prioritized, actionable recommendations to improve system security. Focus on the most critical issues first.',
          result.data.findings
        );
        aiSpinner.succeed('Recommendations ready');
        console.log('\n' + ui.formatAIResponse(analysis) + '\n');
      }
    } catch (error) {
      ui.error(`Hardening check failed: ${error}`);
    }
  }

  private async handleFlows(): Promise<void> {
    ui.section('Pre-configured Workflows');
    console.log(chalk.gray('Choose a workflow to get started quickly\n'));

    // Group flows by category
    const grouped = WORKFLOWS.reduce((acc, flow) => {
      if (!acc[flow.category]) acc[flow.category] = [];
      acc[flow.category].push(flow);
      return acc;
    }, {} as Record<string, typeof WORKFLOWS>);

    const choices = [];

    // Create categorized choices
    for (const [category, flows] of Object.entries(grouped)) {
      choices.push(new inquirer.Separator(chalk.bold.cyan(`\n${category.toUpperCase()}:`)));
      flows.forEach(flow => {
        const difficultyEmoji = {
          beginner: 'üü¢',
          intermediate: 'üü°',
          advanced: 'üî¥',
        }[flow.difficulty];

        choices.push({
          name: `  ${flow.name} ${difficultyEmoji} ${chalk.gray(`(${flow.estimatedTime})`)}`,
          value: flow.id,
          short: flow.name,
        });
      });
    }

    const { selectedFlowId } = await inquirer.prompt([
      {
        type: 'list',
        name: 'selectedFlowId',
        message: 'Select a workflow:',
        choices,
        pageSize: 20,
      },
    ]);

    const selectedFlow = WORKFLOWS.find(f => f.id === selectedFlowId);
    if (!selectedFlow) {
      ui.error('Flow not found');
      return;
    }

    // Show flow details
    ui.section(selectedFlow.name);
    console.log(chalk.gray(selectedFlow.description));
    console.log(chalk.gray(`\nDifficulty: ${selectedFlow.difficulty} | Estimated time: ${selectedFlow.estimatedTime}\n`));

    console.log(chalk.bold('Steps:'));
    selectedFlow.steps.forEach((step, i) => {
      console.log(chalk.gray(`  ${i + 1}. ${step}`));
    });
    console.log('');

    // Confirm execution
    const { confirm } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'confirm',
        message: 'Ready to start this workflow?',
        default: true,
      },
    ]);

    if (!confirm) {
      console.log(chalk.yellow('Workflow cancelled.\n'));
      return;
    }

    // Execute the workflow
    try {
      await this.executeWorkflow(selectedFlow);
    } catch (error: any) {
      ui.error(`Workflow execution failed: ${error.message}`);
    }
  }

  /**
   * Execute a workflow based on its ID
   */
  private async executeWorkflow(flow: typeof WORKFLOWS[0]): Promise<void> {
    switch (flow.id) {
      case 'quick-security-check':
        await this.executeQuickSecurityCheck(flow);
        break;
      case 'website-security-audit':
        await this.executeWebsiteAudit(flow);
        break;
      case 'domain-intel-gathering':
        await this.executeDomainIntel(flow);
        break;
      case 'incident-response-triage':
        await this.executeIncidentTriage(flow);
        break;
      case 'harden-system':
        await this.executeSystemHardening(flow);
        break;
      default:
        console.log(chalk.yellow(`\nWorkflow "${flow.id}" implementation coming soon!`));
        console.log(chalk.gray('Use the standalone command for guided execution:'));
        console.log(chalk.cyan(`  cyber-claude flows\n`));
    }
  }

  /**
   * Quick Security Check Workflow
   */
  private async executeQuickSecurityCheck(flow: typeof WORKFLOWS[0]): Promise<void> {
    const spinner = ui.spinner('Scanning system security...').start();

    const scanResultRaw = await this.scanner.quickCheck();
    spinner.succeed('System scan complete');

    const hardeningSpinner = ui.spinner('Checking security settings...').start();
    const hardeningResultRaw = await this.hardening.checkHardening();
    hardeningSpinner.succeed('Security settings analyzed');

    const allFindings = [
      ...(scanResultRaw.success && scanResultRaw.data?.findings ? scanResultRaw.data.findings : []),
      ...(hardeningResultRaw.success && hardeningResultRaw.data?.findings ? hardeningResultRaw.data.findings : [])
    ];

    const scanResult = this.reporter.createScanResult(allFindings, new Date());
    this.reporter.displayReport(scanResult);

    const aiSpinner = ui.spinner('Getting AI security recommendations...').start();
    const analysis = await this.state.agent.analyze(
      'Analyze this security scan and provide actionable recommendations for improving system security. Focus on the most critical issues first.',
      allFindings
    );
    aiSpinner.succeed('AI analysis complete');

    console.log('');
    ui.section('ü§ñ AI Security Recommendations');
    console.log(ui.formatAIResponse(analysis) + '\n');
  }

  /**
   * Website Security Audit Workflow
   */
  private async executeWebsiteAudit(flow: typeof WORKFLOWS[0]): Promise<void> {
    const { url } = await inquirer.prompt([
      {
        type: 'input',
        name: 'url',
        message: 'Enter website URL to audit:',
        validate: (input) => input.startsWith('http') || 'Please enter a valid URL (http:// or https://)',
      },
    ]);

    console.log(chalk.yellow('\n‚ö†Ô∏è  Make sure you have permission to scan this website!'));
    const { authorized } = await inquirer.prompt([
      {
        type: 'confirm',
        name: 'authorized',
        message: 'Do you have authorization to scan this website?',
        default: false,
      },
    ]);

    if (!authorized) {
      console.log(chalk.red('‚ùå Authorization required. Scan cancelled.\n'));
      return;
    }

    // Use the existing webscan handler
    await this.handleWebScan([url]);
  }

  /**
   * Domain Intelligence Gathering Workflow
   */
  private async executeDomainIntel(flow: typeof WORKFLOWS[0]): Promise<void> {
    const { domain } = await inquirer.prompt([
      {
        type: 'input',
        name: 'domain',
        message: 'Enter domain to investigate:',
        validate: (input) => input.length > 0 || 'Domain is required',
      },
    ]);

    // Use the existing recon handler with --domain flag
    await this.handleRecon([domain, '--domain']);
  }

  /**
   * Incident Response Triage Workflow
   */
  private async executeIncidentTriage(flow: typeof WORKFLOWS[0]): Promise<void> {
    const spinner = ui.spinner('Performing incident triage scan...').start();

    const scanResultRaw = await this.scanner.scanSystem();
    spinner.succeed('Full system scan complete');

    const findings = scanResultRaw.success && scanResultRaw.data?.findings ? scanResultRaw.data.findings : [];
    const scanResult = this.reporter.createScanResult(findings, new Date());
    this.reporter.displayReport(scanResult);

    const aiSpinner = ui.spinner('Analyzing for incident indicators...').start();
    const analysis = await this.state.agent.analyze(
      `Perform incident response triage on this system scan. Look for:
- Suspicious processes or services
- Unusual network connections
- Potential compromise indicators
- Security misconfigurations
- Recommended immediate actions

Provide prioritized findings and actionable next steps.`,
      findings
    );
    aiSpinner.succeed('Incident analysis complete');

    console.log('');
    ui.section('üö® Incident Triage Report');
    console.log(ui.formatAIResponse(analysis) + '\n');
  }

  /**
   * System Hardening Workflow
   */
  private async executeSystemHardening(flow: typeof WORKFLOWS[0]): Promise<void> {
    const spinner = ui.spinner('Auditing security configuration...').start();

    const resultsRaw = await this.hardening.checkHardening();
    spinner.succeed('Security audit complete');

    const findings = resultsRaw.success && resultsRaw.data?.findings ? resultsRaw.data.findings : [];
    const scanResult = this.reporter.createScanResult(findings, new Date());
    this.reporter.displayReport(scanResult);

    const aiSpinner = ui.spinner('Generating hardening recommendations...').start();
    const analysis = await this.state.agent.analyze(
      'Based on this security audit, provide step-by-step hardening recommendations. Prioritize by impact and include specific commands or settings to change where applicable.',
      findings
    );
    aiSpinner.succeed('Hardening guide generated');

    console.log('');
    ui.section('üîí System Hardening Guide');
    console.log(ui.formatAIResponse(analysis) + '\n');
  }

  /**
   * Handle autonomous task execution
   */
  private async handleAuto(command: string): Promise<void> {
    // Extract task from command (everything after "auto ")
    const task = command.substring(5).trim(); // Remove "auto " prefix

    if (!task) {
      ui.error('Please provide a task description');
      ui.info('Usage: auto <task description>');
      ui.info('Example: auto scan example.com for vulnerabilities');
      ui.info('Example: auto gather intel on target-company.com');
      return;
    }

    // Import AgenticCore dynamically
    const { AgenticCore } = await import('../agent/core/agentic.js');

    ui.section('ü§ñ AUTONOMOUS AGENT');
    console.log(chalk.gray(`Task: ${task}`));
    console.log(chalk.gray(`Mode: ${this.state.mode.toUpperCase()}`));
    console.log(chalk.gray(`Model: ${this.state.model}\n`));

    try {
      // Get model info
      const modelInfo = getModelByKey(this.state.model as ModelKey);
      if (!modelInfo) {
        throw new Error(`Invalid model: ${this.state.model}`);
      }

      // Create agentic config using session's current mode and model
      const agenticConfig = {
        apiKey: modelInfo.provider === 'claude' ? config.anthropicApiKey : undefined,
        googleApiKey: modelInfo.provider === 'gemini' ? config.googleApiKey : undefined,
        model: modelInfo.id,
        mode: this.state.mode,
        maxSteps: 20,
        maxDuration: 600000,
        autoApprove: false,
        verbose: true, // Always verbose in interactive mode
      };

      const agent = new AgenticCore(agenticConfig);
      const result = await agent.executeTask(task);

      if (result.success) {
        ui.success('\n‚úÖ Task completed successfully');

        const summary = {
          stepsCompleted: result.context.completedSteps.length,
          stepsTotal: result.context.plan.steps.length,
          findingsCount: result.context.findings.length,
          errorsCount: result.context.errors.length,
          duration: (result.duration / 1000).toFixed(1) + 's',
        };

        ui.box(
          `Steps: ${summary.stepsCompleted}/${summary.stepsTotal}\n` +
          `Findings: ${summary.findingsCount}\n` +
          `Errors: ${summary.errorsCount}\n` +
          `Duration: ${summary.duration}`
        );

        // Show findings if any
        if (result.context.findings.length > 0) {
          console.log('\n' + chalk.bold('Security Findings:'));
          result.context.findings.slice(0, 5).forEach((finding, idx) => {
            console.log(chalk.gray(`${idx + 1}. [${finding.severity.toUpperCase()}] ${finding.title}`));
          });

          if (result.context.findings.length > 5) {
            console.log(chalk.gray(`  ... and ${result.context.findings.length - 5} more`));
          }
        }

        console.log('');
      } else {
        ui.error('\n‚ùå Task failed');
        ui.box(`Error: ${result.error}\nDuration: ${(result.duration / 1000).toFixed(1)}s`);
      }
    } catch (error) {
      ui.error(`\nAutonomous execution failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  private async handleChat(message: string): Promise<void> {
    const spinner = ui.spinner('Thinking...');

    try {
      const response = await this.state.agent.chat(message);
      spinner.stop();

      console.log(chalk.magenta('\nCyber Claude:'));
      console.log(ui.formatAIResponse(response) + '\n');
    } catch (error) {
      spinner.fail('Error communicating with agent');
      ui.error(`${error}`);
    }
  }

  private async handleWebScan(args: string[]): Promise<void> {
    if (args.length === 0) {
      ui.error('Please provide a URL to scan');
      ui.info('Usage: webscan <url>');
      return;
    }

    const url = args[0];

    try {
      console.log('');
      ui.section(`Web Security Scan: ${url}`);
      console.log('');

      // Progress callback
      const onProgress = (message: string) => {
        console.log(message);
      };

      const result = await this.webScanner.quickScan(url, { onProgress });
      ui.success('‚úì Web scan completed\n');

      console.log(`Target: ${result.target.url}`);
      console.log(`Findings: ${result.summary.total}`);
      console.log('');

      let analysis: string | undefined;
      if (result.findings.length > 0) {
        result.findings.slice(0, 5).forEach(finding => {
          ui.finding(finding.severity, finding.title, finding.description);
        });

        if (result.findings.length > 5) {
          console.log(`\n... and ${result.findings.length - 5} more findings`);
        }

        // AI Analysis
        const aiSpinner = ui.spinner('ü§ñ Analyzing with AI...');
        analysis = await this.state.agent.analyze(
          'Analyze these web security findings. Prioritize issues and provide remediation guidance.',
          { findings: result.findings, target: result.target }
        );
        aiSpinner.succeed('‚úì Analysis complete');
        console.log('\n' + ui.formatAIResponse(analysis) + '\n');
      } else {
        ui.success('No security issues found!');
      }

      // Save scan results
      const savedPath = await saveScanResults(result, analysis);
      ui.success(`üìÅ Scan results saved to: ${savedPath}`);
    } catch (error) {
      ui.error(`Web scan failed: ${error}`);
    }
  }

  private async handlePcap(args: string[]): Promise<void> {
    if (args.length === 0) {
      ui.error('Please provide a pcap file to analyze');
      ui.info('Usage: pcap <file.pcap>');
      return;
    }

    const filePath = args[0];

    try {
      console.log('');
      ui.section(`üì¶ Network Traffic Analysis: ${filePath}`);
      console.log('');

      const spinner = ui.spinner('Parsing pcap file...');
      const analysis = await this.pcapAnalyzer.analyze(filePath, {
        includePackets: false,
        statisticsOnly: false,
      });
      spinner.succeed('Pcap file parsed successfully');
      console.log('');

      // Display summary
      this.pcapReporter.displaySummary(analysis);

      // AI Analysis
      if (analysis.packetCount > 0) {
        const aiSpinner = ui.spinner('ü§ñ Analyzing network traffic with AI...');

        // Build analysis prompt
        let prompt = `Analyze the following network traffic capture:\n\n`;
        prompt += `File: ${analysis.filename}\n`;
        prompt += `Packets: ${analysis.packetCount.toLocaleString()}\n`;
        prompt += `Duration: ${this.formatDuration(analysis.captureDuration)}\n\n`;

        prompt += `Protocol Distribution:\n`;
        for (const stat of analysis.protocolStats.slice(0, 10)) {
          prompt += `- ${stat.protocol}: ${stat.packets} packets (${stat.percentage.toFixed(1)}%)\n`;
        }
        prompt += `\n`;

        if (analysis.conversations.length > 0) {
          prompt += `Top Conversations:\n`;
          for (const conv of analysis.conversations.slice(0, 5)) {
            prompt += `- ${conv.protocol} ${conv.sourceAddr}:${conv.sourcePort} ‚Üî `;
            prompt += `${conv.destAddr}:${conv.destPort} (${conv.packets} packets)\n`;
          }
          prompt += `\n`;
        }

        if (analysis.alerts.length > 0) {
          prompt += `‚ö†Ô∏è Detected Alerts:\n`;
          for (const alert of analysis.alerts) {
            prompt += `- ${alert}\n`;
          }
          prompt += `\n`;
        }

        prompt += `Provide a security analysis of this network traffic, highlighting:\n`;
        prompt += `1. Overall traffic patterns and what they indicate\n`;
        prompt += `2. Any suspicious or unusual activity\n`;
        prompt += `3. Security concerns and potential threats\n`;
        prompt += `4. Recommendations for further investigation\n`;

        const aiResponse = await this.state.agent.analyze(
          prompt,
          'network traffic analysis'
        );
        aiSpinner.succeed('‚úì Analysis complete');
        console.log('\n' + ui.formatAIResponse(aiResponse) + '\n');
      }

      ui.success('‚úì Pcap analysis complete!');
    } catch (error: any) {
      ui.error(`Pcap analysis failed: ${error.message}`);
    }
  }

  private async handleRecon(args: string[]): Promise<void> {
    if (args.length === 0) {
      ui.error('Please provide a target to investigate');
      ui.info('Usage: recon <domain|username|ip>');
      ui.info('Options: --quick, --full, --domain, --person');
      return;
    }

    const target = args[0];

    // Parse options
    let scanType: 'quick' | 'full' | 'domain' | 'person' = 'quick';
    if (args.includes('--full')) scanType = 'full';
    else if (args.includes('--domain')) scanType = 'domain';
    else if (args.includes('--person')) scanType = 'person';

    try {
      console.log('');
      ui.section(`üîç OSINT Reconnaissance: ${target}`);
      console.log(`Scan Type: ${scanType.toUpperCase()}`);
      console.log('');

      const spinner = ui.spinner('Starting reconnaissance...');

      let result;
      try {
        switch (scanType) {
          case 'quick':
            result = await this.osintOrchestrator.quickScan(target);
            break;
          case 'full':
            result = await this.osintOrchestrator.fullScan(target);
            break;
          case 'domain':
            result = await this.osintOrchestrator.domainScan(target);
            break;
          case 'person':
            result = await this.osintOrchestrator.personScan(target);
            break;
        }
        spinner.succeed('Reconnaissance completed');
      } catch (error) {
        spinner.fail('Reconnaissance failed');
        throw error;
      }

      console.log('');

      // Display results
      this.osintReporter.displayResults(result);

      // AI Analysis
      if (result.summary.totalFindings > 0) {
        const aiSpinner = ui.spinner('ü§ñ Analyzing OSINT findings with AI...');

        // Build analysis prompt
        let prompt = `Analyze the following OSINT reconnaissance results:\n\n`;
        prompt += `Target: ${result.target}\n`;
        prompt += `Findings: ${result.summary.totalFindings}\n`;
        prompt += `Risk Score: ${result.summary.riskScore}/100\n\n`;

        // Add key findings
        if (result.results.dns) {
          prompt += `DNS Records Found: ${Object.keys(result.results.dns.records).length} types\n`;
        }
        if (result.results.whois) {
          prompt += `WHOIS: ${result.results.whois.registrar || 'Unknown registrar'}\n`;
        }
        if (result.results.subdomains && result.results.subdomains.total > 0) {
          prompt += `Subdomains: ${result.results.subdomains.total} discovered\n`;
        }
        if (result.results.emails && result.results.emails.total > 0) {
          prompt += `Emails: ${result.results.emails.total} addresses found\n`;
        }
        if (result.results.usernames && result.results.usernames.totalFound > 0) {
          prompt += `Social Media: ${result.results.usernames.totalFound} profiles found\n`;
        }
        if (result.results.breaches && result.results.breaches.length > 0) {
          prompt += `‚ö†Ô∏è Data Breaches: ${result.results.breaches.length} breach(es) found\n`;
        }

        prompt += `\nProvide:\n`;
        prompt += `1. Security posture assessment\n`;
        prompt += `2. Attack surface analysis\n`;
        prompt += `3. Privacy and exposure concerns\n`;
        prompt += `4. Recommendations for hardening\n`;

        const aiResponse = await this.state.agent.analyze(
          prompt,
          result
        );
        aiSpinner.succeed('‚úì Analysis complete');
        console.log('\n' + ui.formatAIResponse(aiResponse) + '\n');
      }

      // Summary
      const riskLevel =
        result.summary.riskScore > 70
          ? 'HIGH'
          : result.summary.riskScore > 40
            ? 'MEDIUM'
            : 'LOW';

      ui.info(`Scan completed: ${result.summary.totalFindings} findings | Risk: ${riskLevel}`);
    } catch (error: any) {
      ui.error(`Reconnaissance failed: ${error.message || error}`);
    }
  }

  private formatDuration(ms: number): string {
    if (ms < 1000) return `${ms}ms`;
    if (ms < 60000) return `${(ms / 1000).toFixed(2)}s`;
    if (ms < 3600000) return `${(ms / 60000).toFixed(2)}m`;
    return `${(ms / 3600000).toFixed(2)}h`;
  }

  /**
   * Handle CVE lookup command
   */
  private async handleCVE(args: string[]): Promise<void> {
    if (args.length === 0) {
      ui.error('Please provide a CVE ID or search keyword');
      ui.info('Usage: cve <cve-id|keyword>');
      ui.info('Example: cve CVE-2024-1234');
      ui.info('Example: cve apache');
      return;
    }

    const query = args.join(' ');
    const isCVEId = /^CVE-\d{4}-\d+$/i.test(query);

    try {
      const { VulnerabilityDB } = await import('../agent/tools/vuln/VulnerabilityDB.js');
      const vulnDb = new VulnerabilityDB();

      if (isCVEId) {
        // Direct CVE lookup
        const spinner = ui.spinner(`Looking up ${query}...`);
        const cve = await vulnDb.getCVE(query);
        spinner.succeed('CVE data retrieved');

        if (!cve) {
          ui.error(`CVE ${query} not found in database`);
          return;
        }

        // Display CVE info
        console.log('\n' + chalk.bold.cyan('‚ïê'.repeat(80)));
        console.log(chalk.bold.cyan(`CVE ID: ${cve.id}`));
        console.log(chalk.bold.cyan('‚ïê'.repeat(80)) + '\n');

        console.log(chalk.bold('Description:'));
        const englishDesc = cve.descriptions.find(d => d.lang === 'en') || cve.descriptions[0];
        console.log(chalk.gray(englishDesc?.value || 'No description available') + '\n');

        // Get CVSS score (prefer V3 over V2)
        const cvss = cve.cvssV3 || cve.cvssV2;
        if (cvss) {
          const severityMap: Record<string, typeof chalk.red> = {
            'CRITICAL': chalk.red,
            'HIGH': chalk.red,
            'MEDIUM': chalk.yellow,
            'LOW': chalk.green,
            'NONE': chalk.blue,
          };
          const severityColor = severityMap[cvss.baseSeverity] || chalk.white;

          console.log(chalk.bold('CVSS Score: ') + severityColor(`${cvss.baseScore}/10 (${cvss.baseSeverity})`));
        }

        if (cve.published) {
          console.log(chalk.bold('Published: ') + new Date(cve.published).toLocaleDateString());
        }

        if (cve.lastModified) {
          console.log(chalk.bold('Last Modified: ') + new Date(cve.lastModified).toLocaleDateString());
        }

        if (cve.references && cve.references.length > 0) {
          console.log('\n' + chalk.bold('References:'));
          cve.references.slice(0, 5).forEach(ref => {
            console.log(chalk.gray('  - ' + ref));
          });
          if (cve.references.length > 5) {
            console.log(chalk.gray(`  ... and ${cve.references.length - 5} more`));
          }
        }

        console.log('');
      } else {
        // Keyword search
        const spinner = ui.spinner(`Searching for "${query}"...`);
        const results = await vulnDb.searchCVEs({
          keyword: query,
          resultsPerPage: 10,
        });
        spinner.succeed(`Found ${results.totalResults} vulnerabilities`);

        if (results.vulnerabilities.length === 0) {
          ui.info('No vulnerabilities found matching that keyword');
          return;
        }

        console.log('\n' + chalk.bold(`Top ${results.vulnerabilities.length} results:\n`));

        results.vulnerabilities.forEach((cve, idx) => {
          const cvss = cve.cvssV3 || cve.cvssV2;
          const severityMap: Record<string, typeof chalk.red> = {
            'CRITICAL': chalk.red,
            'HIGH': chalk.red,
            'MEDIUM': chalk.yellow,
            'LOW': chalk.green,
            'NONE': chalk.blue,
          };
          const severityColor = cvss ? (severityMap[cvss.baseSeverity] || chalk.white) : chalk.white;
          const severityText = cvss ? cvss.baseSeverity : 'UNKNOWN';

          console.log(chalk.bold(`${idx + 1}. ${cve.id}`) + ` ${severityColor(`[${severityText}]`)}`);
          const englishDesc = cve.descriptions.find(d => d.lang === 'en') || cve.descriptions[0];
          const description = englishDesc?.value || 'No description';
          console.log(chalk.gray('   ' + (description.substring(0, 100) + (description.length > 100 ? '...' : ''))));
          console.log('');
        });
      }
    } catch (error: any) {
      ui.error(`CVE lookup failed: ${error.message}`);
    }
  }

  /**
   * Handle log analysis command
   */
  private async handleLogs(args: string[]): Promise<void> {
    if (args.length === 0) {
      ui.error('Please provide a log file to analyze');
      ui.info('Usage: logs <file>');
      ui.info('Example: logs /var/log/auth.log');
      ui.info('Example: logs access.log');
      return;
    }

    const filePath = args[0];

    try {
      console.log('');
      ui.section(`üìù Log Analysis: ${filePath}`);
      console.log('');

      const { LogAnalyzer } = await import('../agent/tools/log/LogAnalyzer.js');
      const analyzer = new LogAnalyzer();

      const spinner = ui.spinner('Analyzing log file...');
      const result = await analyzer.analyze(filePath, {
        format: 'auto',
        detectAnomalies: true,
        maxLines: 10000,
      });
      spinner.succeed('Log analysis completed');

      console.log('');
      console.log(chalk.bold('File: ') + result.filePath);
      console.log(chalk.bold('Format: ') + result.format);
      console.log(chalk.bold('Total Entries: ') + result.statistics.parsedLines.toLocaleString());
      console.log('');

      // Show severity distribution
      if (result.statistics.severityDistribution) {
        console.log(chalk.bold('Severity Distribution:'));
        const severities: Array<'emergency' | 'alert' | 'critical' | 'error' | 'warning' | 'notice' | 'info' | 'debug'> =
          ['emergency', 'alert', 'critical', 'error', 'warning', 'notice', 'info', 'debug'];
        severities.forEach(sev => {
          const count = result.statistics.severityDistribution[sev] || 0;
          if (count > 0) {
            console.log(chalk.gray(`  ${sev}: ${count}`));
          }
        });
        console.log('');
      }

      // Show anomalies
      if (result.anomalies && result.anomalies.length > 0) {
        console.log(chalk.bold.red(`‚ö†Ô∏è  Detected ${result.anomalies.length} Anomalies:\n`));

        result.anomalies.slice(0, 10).forEach((anomaly, idx) => {
          const severityColor = {
            critical: chalk.red,
            high: chalk.red,
            medium: chalk.yellow,
            low: chalk.green,
            info: chalk.blue,
          }[anomaly.severity] || chalk.white;

          console.log(severityColor(`${idx + 1}. [${anomaly.severity.toUpperCase()}] ${anomaly.type}: ${anomaly.description}`));
          if (anomaly.recommendation) {
            console.log(chalk.gray(`   ‚Üí ${anomaly.recommendation}`));
          }
          console.log('');
        });

        if (result.anomalies.length > 10) {
          console.log(chalk.gray(`... and ${result.anomalies.length - 10} more anomalies\n`));
        }
      } else {
        ui.success('No anomalies detected');
        console.log('');
      }

      // AI Analysis
      if (result.anomalies && result.anomalies.length > 0) {
        const aiSpinner = ui.spinner('ü§ñ Analyzing with AI...');
        const analysis = await this.state.agent.analyze(
          'Analyze these log file anomalies and security events. Identify patterns, assess risk, and provide actionable recommendations.',
          { filePath: result.filePath, statistics: result.statistics, anomalies: result.anomalies }
        );
        aiSpinner.succeed('‚úì Analysis complete');
        console.log('\n' + ui.formatAIResponse(analysis) + '\n');
      }

      ui.success('‚úì Log analysis complete!');
    } catch (error: any) {
      ui.error(`Log analysis failed: ${error.message}`);
    }
  }

  /**
   * Handle daemon command
   */
  private async handleDaemon(args: string[]): Promise<void> {
    if (args.length === 0) {
      ui.info('Daemon command requires a subcommand');
      ui.info('Available subcommands: status, jobs, start, stop, add, remove, enable, disable, run');
      ui.info('Example: daemon status');
      ui.info('Example: daemon jobs');
      ui.info('Note: Use standalone command for full daemon features: cyber-claude daemon <subcommand>');
      return;
    }

    const subcommand = args[0];

    try {
      const { Daemon } = await import('../daemon/Daemon.js');
      const daemon = new Daemon();

      switch (subcommand) {
        case 'status': {
          await daemon.start();
          const status = daemon.getStatus();
          daemon.stop();

          console.log('');
          ui.section('Daemon Status');
          console.log(`Running: ${status.running ? chalk.green('Yes') : chalk.red('No')}`);
          if (status.running) {
            console.log(`Jobs executed: ${status.jobsExecuted}`);
            console.log(`Jobs failed: ${status.jobsFailed}`);
            if (status.nextScheduledJob) {
              console.log(`Next job: ${status.nextScheduledJob.jobName} at ${status.nextScheduledJob.scheduledTime.toLocaleString()}`);
            }
          }
          console.log('');
          break;
        }

        case 'jobs': {
          await daemon.start();
          const jobs = daemon.getJobs();
          daemon.stop();

          if (jobs.length === 0) {
            ui.info('No scheduled jobs');
            ui.info('Use "cyber-claude daemon add" to create a scheduled job');
          } else {
            console.log('');
            ui.section(`Scheduled Jobs (${jobs.length})`);
            jobs.forEach(job => {
              const statusIcon = job.enabled ? chalk.green('‚úì') : chalk.gray('‚óã');
              console.log(`${statusIcon} ${chalk.bold(job.name)} (${job.type})`);
              console.log(chalk.gray(`  Schedule: ${job.schedule}`));
              if (job.lastRun) {
                console.log(chalk.gray(`  Last run: ${job.lastRun.toLocaleString()}`));
              }
              console.log('');
            });
          }
          break;
        }

        default:
          ui.info(`For daemon subcommand "${subcommand}", use the standalone command:`);
          ui.info(chalk.cyan(`cyber-claude daemon ${args.join(' ')}`));
          ui.info('The interactive session supports: status, jobs');
      }
    } catch (error: any) {
      ui.error(`Daemon command failed: ${error.message}`);
    }
  }
}
/**
 * Vulnerability Database
 * Integration with NVD (National Vulnerability Database) API
 * API Docs: https://nvd.nist.gov/developers/vulnerabilities
 */

import axios, { AxiosInstance } from 'axios';
import { VulnCache } from './VulnCache.js';
import {
  CVEData,
  CVESearchCriteria,
  CVESearchResults,
  VulnerabilityInfo,
  ProductVersion,
  CVSSScore,
} from './types.js';
import { logger } from '../../../utils/logger.js';

export class VulnerabilityDB {
  private client: AxiosInstance;
  private cache: VulnCache;
  private apiKey?: string;
  private baseURL = 'https://services.nvd.nist.gov/rest/json/cves/2.0';

  constructor(apiKey?: string) {
    this.apiKey = apiKey;
    this.cache = new VulnCache();

    // Initialize axios client
    this.client = axios.create({
      baseURL: this.baseURL,
      timeout: 30000,
      headers: {
        'User-Agent': 'Cyber-Claude/1.0',
        ...(apiKey ? { 'apiKey': apiKey } : {}),
      },
    });

    // Initialize cache
    this.cache.initialize().catch(err => {
      logger.warn(`Failed to initialize vulnerability cache: ${err.message}`);
    });
  }

  /**
   * Get CVE by ID
   */
  async getCVE(cveId: string): Promise<CVEData | null> {
    try {
      // Check cache first
      const cached = await this.cache.get(cveId);
      if (cached) {
        logger.debug(`Returning cached CVE data for ${cveId}`);
        return cached;
      }

      // Query NVD API
      logger.info(`Fetching CVE ${cveId} from NVD API`);
      const response = await this.client.get('', {
        params: {
          cveId,
        },
      });

      // Rate limiting: wait if no API key (5 requests per 30 seconds for public)
      if (!this.apiKey) {
        await this.sleep(6000); // 6 seconds between requests
      }

      if (!response.data || !response.data.vulnerabilities || response.data.vulnerabilities.length === 0) {
        logger.warn(`CVE ${cveId} not found in NVD`);
        return null;
      }

      // Parse the CVE data
      const vuln = response.data.vulnerabilities[0];
      const cveData = this.parseCVE(vuln);

      // Cache the result
      await this.cache.set(cveId, cveData);

      return cveData;

    } catch (error: any) {
      if (error.response?.status === 404) {
        logger.warn(`CVE ${cveId} not found`);
        return null;
      }

      logger.error(`Failed to fetch CVE ${cveId}: ${error.message}`);
      throw new Error(`Failed to fetch CVE data: ${error.message}`);
    }
  }

  /**
   * Search for CVEs
   */
  async searchCVEs(criteria: CVESearchCriteria): Promise<CVESearchResults> {
    try {
      const params: any = {
        resultsPerPage: criteria.resultsPerPage || 20,
        startIndex: criteria.startIndex || 0,
      };

      if (criteria.cveId) {
        params.cveId = criteria.cveId;
      }

      if (criteria.keyword) {
        params.keywordSearch = criteria.keyword;
      }

      if (criteria.cpeName) {
        params.cpeName = criteria.cpeName;
      }

      if (criteria.severityMin) {
        params.cvssV3Severity = criteria.severityMin;
      }

      if (criteria.publishedStartDate) {
        params.pubStartDate = criteria.publishedStartDate.toISOString();
      }

      if (criteria.publishedEndDate) {
        params.pubEndDate = criteria.publishedEndDate.toISOString();
      }

      logger.info(`Searching CVEs with criteria: ${JSON.stringify(criteria)}`);
      const response = await this.client.get('', { params });

      // Rate limiting
      if (!this.apiKey) {
        await this.sleep(6000);
      }

      const results: CVESearchResults = {
        totalResults: response.data.totalResults || 0,
        resultsPerPage: response.data.resultsPerPage || 0,
        startIndex: response.data.startIndex || 0,
        vulnerabilities: [],
      };

      if (response.data.vulnerabilities) {
        results.vulnerabilities = response.data.vulnerabilities.map((v: any) => this.parseCVE(v));

        // Cache individual CVEs
        for (const cve of results.vulnerabilities) {
          await this.cache.set(cve.id, cve);
        }
      }

      return results;

    } catch (error: any) {
      logger.error(`CVE search failed: ${error.message}`);
      throw new Error(`CVE search failed: ${error.message}`);
    }
  }

  /**
   * Get vulnerabilities for a specific product/version
   */
  async getVulnerabilitiesForProduct(product: ProductVersion): Promise<VulnerabilityInfo[]> {
    try {
      // Build CPE name or keyword search
      const keyword = product.vendor
        ? `${product.vendor} ${product.product} ${product.version}`
        : `${product.product} ${product.version}`;

      const results = await this.searchCVEs({
        keyword,
        resultsPerPage: 50,
      });

      // Convert to simplified format
      return results.vulnerabilities.map(cve => this.toVulnerabilityInfo(cve));

    } catch (error: any) {
      logger.error(`Failed to get vulnerabilities for product: ${error.message}`);
      return [];
    }
  }

  /**
   * Parse CVE from NVD API response
   */
  private parseCVE(vulnData: any): CVEData {
    const cve = vulnData.cve;

    const cveData: CVEData = {
      id: cve.id,
      sourceIdentifier: cve.sourceIdentifier,
      published: new Date(cve.published),
      lastModified: new Date(cve.lastModified),
      vulnStatus: cve.vulnStatus,
      descriptions: cve.descriptions || [],
      references: (cve.references || []).map((ref: any) => ({
        url: ref.url,
        source: ref.source,
        tags: ref.tags,
      })),
    };

    // Parse CVSS scores
    if (cve.metrics) {
      if (cve.metrics.cvssMetricV31 && cve.metrics.cvssMetricV31.length > 0) {
        const metric = cve.metrics.cvssMetricV31[0];
        cveData.cvssV3 = {
          version: '3.1',
          vectorString: metric.cvssData.vectorString,
          baseScore: metric.cvssData.baseScore,
          baseSeverity: metric.cvssData.baseSeverity,
          exploitabilityScore: metric.exploitabilityScore,
          impactScore: metric.impactScore,
        };
      } else if (cve.metrics.cvssMetricV30 && cve.metrics.cvssMetricV30.length > 0) {
        const metric = cve.metrics.cvssMetricV30[0];
        cveData.cvssV3 = {
          version: '3.0',
          vectorString: metric.cvssData.vectorString,
          baseScore: metric.cvssData.baseScore,
          baseSeverity: metric.cvssData.baseSeverity,
          exploitabilityScore: metric.exploitabilityScore,
          impactScore: metric.impactScore,
        };
      }

      if (cve.metrics.cvssMetricV2 && cve.metrics.cvssMetricV2.length > 0) {
        const metric = cve.metrics.cvssMetricV2[0];
        cveData.cvssV2 = {
          version: '2.0',
          vectorString: metric.cvssData.vectorString,
          baseScore: metric.cvssData.baseScore,
          baseSeverity: this.cvss2ToSeverity(metric.cvssData.baseScore),
          exploitabilityScore: metric.exploitabilityScore,
          impactScore: metric.impactScore,
        };
      }
    }

    // Parse configurations (affected products)
    if (cve.configurations && cve.configurations.length > 0) {
      cveData.configurations = {
        nodes: cve.configurations.map((config: any) => ({
          operator: config.operator || 'OR',
          cpeMatch: (config.nodes?.[0]?.cpeMatch || []).map((match: any) => ({
            criteria: match.criteria,
            matchCriteriaId: match.matchCriteriaId,
            vulnerable: match.vulnerable !== false,
            versionStartIncluding: match.versionStartIncluding,
            versionStartExcluding: match.versionStartExcluding,
            versionEndIncluding: match.versionEndIncluding,
            versionEndExcluding: match.versionEndExcluding,
          })),
        })),
      };
    }

    // Parse weaknesses (CWE)
    if (cve.weaknesses && cve.weaknesses.length > 0) {
      cveData.weaknesses = cve.weaknesses.flatMap((w: any) =>
        w.description.map((d: any) => ({
          id: d.value,
          name: d.value,
        }))
      );
    }

    return cveData;
  }

  /**
   * Convert CVEData to simplified VulnerabilityInfo
   */
  private toVulnerabilityInfo(cve: CVEData): VulnerabilityInfo {
    const description = cve.descriptions.find(d => d.lang === 'en')?.value ||
                       cve.descriptions[0]?.value ||
                       'No description available';

    const cvss = cve.cvssV3 || cve.cvssV2;
    const severity = this.cvssToStandardSeverity(cvss?.baseSeverity || 'MEDIUM');

    return {
      cveId: cve.id,
      description,
      severity,
      cvssScore: cvss?.baseScore,
      cvssVector: cvss?.vectorString,
      published: cve.published,
      lastModified: cve.lastModified,
      references: cve.references.map(r => r.url),
      cwe: cve.weaknesses?.map(w => w.id),
    };
  }

  /**
   * Convert CVSS 2.0 score to severity
   */
  private cvss2ToSeverity(score: number): 'NONE' | 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    if (score === 0) return 'NONE';
    if (score < 4.0) return 'LOW';
    if (score < 7.0) return 'MEDIUM';
    if (score < 9.0) return 'HIGH';
    return 'CRITICAL';
  }

  /**
   * Convert CVSS severity to standard severity levels
   */
  private cvssToStandardSeverity(cvss: string): 'critical' | 'high' | 'medium' | 'low' | 'info' {
    switch (cvss.toUpperCase()) {
      case 'CRITICAL': return 'critical';
      case 'HIGH': return 'high';
      case 'MEDIUM': return 'medium';
      case 'LOW': return 'low';
      default: return 'info';
    }
  }

  /**
   * Sleep helper for rate limiting
   */
  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  /**
   * Clear cache
   */
  async clearCache(): Promise<number> {
    return await this.cache.clear();
  }

  /**
   * Get cache stats
   */
  async getCacheStats() {
    return await this.cache.getStats();
  }
}

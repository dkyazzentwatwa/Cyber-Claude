import inquirer from 'inquirer';
import chalk from 'chalk';
import { ui } from '../utils/ui.js';
import { CyberAgent } from '../agent/core.js';
import { DesktopScanner } from '../agent/tools/scanner.js';
import { HardeningChecker } from '../agent/tools/hardening.js';
import { SecurityReporter } from '../agent/tools/reporter.js';
import { WebScanner } from '../agent/tools/web/WebScanner.js';
import { PcapAnalyzer } from '../agent/tools/PcapAnalyzer.js';
import { PcapReporter } from '../agent/tools/PcapReporter.js';
import { OSINTOrchestrator, OSINTReporter } from '../agent/tools/osint/index.js';
import { WORKFLOWS } from './commands/flows.js';
import { config } from '../utils/config.js';
import { AVAILABLE_MODELS, getModelByKey } from '../utils/models.js';
import { promises as fs } from 'fs';
import * as path from 'path';
/**
 * Save scan results to the /scans directory as markdown
 */
async function saveScanResults(result, analysis) {
    // Create scans directory if it doesn't exist
    const scansDir = path.join(process.cwd(), 'scans');
    await fs.mkdir(scansDir, { recursive: true });
    // Generate filename from hostname and timestamp
    const hostname = result.target.hostname.replace(/[^a-zA-Z0-9.-]/g, '_');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `${hostname}_${timestamp}.md`;
    const filepath = path.join(scansDir, filename);
    // Format markdown content
    const markdown = formatScanMarkdown(result, analysis);
    // Write to file
    await fs.writeFile(filepath, markdown, 'utf-8');
    return filepath;
}
/**
 * Format scan results as markdown
 */
function formatScanMarkdown(result, analysis) {
    const lines = [];
    // Header
    lines.push(`# Web Security Scan Report`);
    lines.push(`\n**Target:** ${result.target.url}`);
    lines.push(`**Scan Date:** ${new Date(result.scanTime).toLocaleString()}`);
    lines.push(`**Duration:** ${result.duration}ms`);
    lines.push(`**Protocol:** ${result.target.protocol.toUpperCase()}`);
    if (result.technology?.server) {
        lines.push(`**Server:** ${result.technology.server}`);
    }
    lines.push('');
    // Summary
    lines.push(`## Summary`);
    lines.push('');
    lines.push(`| Severity | Count |`);
    lines.push(`|----------|-------|`);
    lines.push(`| 🔴 Critical | ${result.summary.critical} |`);
    lines.push(`| 🟠 High | ${result.summary.high} |`);
    lines.push(`| 🟡 Medium | ${result.summary.medium} |`);
    lines.push(`| 🟢 Low | ${result.summary.low} |`);
    lines.push(`| 🔵 Info | ${result.summary.info} |`);
    lines.push(`| **Total** | **${result.summary.total}** |`);
    lines.push('');
    // Findings
    if (result.findings.length > 0) {
        lines.push(`## Findings`);
        lines.push('');
        // Group by severity
        const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
        for (const severity of severityOrder) {
            const findings = result.findings.filter(f => f.severity === severity);
            if (findings.length === 0)
                continue;
            const emoji = {
                critical: '🔴',
                high: '🟠',
                medium: '🟡',
                low: '🟢',
                info: '🔵'
            }[severity];
            lines.push(`### ${emoji} ${severity.toUpperCase()}`);
            lines.push('');
            findings.forEach((finding, index) => {
                lines.push(`#### ${index + 1}. ${finding.title}`);
                lines.push('');
                lines.push(`**Description:** ${finding.description}`);
                lines.push('');
                if (finding.remediation) {
                    lines.push(`**Remediation:** ${finding.remediation}`);
                    lines.push('');
                }
                if (finding.references && finding.references.length > 0) {
                    lines.push(`**References:**`);
                    finding.references.forEach(ref => {
                        lines.push(`- ${ref}`);
                    });
                    lines.push('');
                }
                lines.push(`**Category:** ${finding.category}`);
                lines.push('');
                lines.push('---');
                lines.push('');
            });
        }
    }
    else {
        lines.push(`## Findings`);
        lines.push('');
        lines.push(`✅ No security issues found!`);
        lines.push('');
    }
    // AI Analysis
    if (analysis) {
        lines.push(`## AI Security Analysis`);
        lines.push('');
        lines.push(analysis);
        lines.push('');
    }
    // Footer
    lines.push('---');
    lines.push('');
    lines.push(`*Report generated by Cyber Claude on ${new Date().toLocaleString()}*`);
    return lines.join('\n');
}
export class InteractiveSession {
    state;
    scanner;
    hardening;
    reporter;
    webScanner;
    pcapAnalyzer;
    pcapReporter;
    osintOrchestrator;
    osintReporter;
    constructor(initialMode = 'base', model) {
        this.scanner = new DesktopScanner();
        this.hardening = new HardeningChecker();
        this.reporter = new SecurityReporter();
        this.webScanner = new WebScanner();
        this.pcapAnalyzer = new PcapAnalyzer();
        this.pcapReporter = new PcapReporter();
        this.osintOrchestrator = new OSINTOrchestrator();
        this.osintReporter = new OSINTReporter();
        const selectedModel = model || config.model;
        this.state = {
            agent: new CyberAgent({
                mode: initialMode,
                apiKey: config.anthropicApiKey,
                googleApiKey: config.googleApiKey,
                model: selectedModel,
            }),
            mode: initialMode,
            model: selectedModel,
            commandHistory: [],
        };
    }
    /**
     * Start the interactive session
     */
    async start() {
        ui.clear();
        ui.banner();
        this.showModeStatus();
        this.showWelcome();
        // Main session loop
        while (true) {
            try {
                const prompt = this.getPrompt();
                const { command } = await inquirer.prompt({
                    type: 'input',
                    name: 'command',
                    message: prompt,
                    prefix: '',
                });
                if (!command || command.trim() === '') {
                    continue;
                }
                const trimmedCommand = command.trim();
                this.state.commandHistory.push(trimmedCommand);
                // Handle commands
                const shouldExit = await this.handleCommand(trimmedCommand);
                if (shouldExit) {
                    break;
                }
            }
            catch (error) {
                // User pressed Ctrl+C or error occurred
                console.log('\n');
                ui.info('Exiting session...');
                break;
            }
        }
    }
    getPrompt() {
        const modeIcons = {
            base: '🤖',
            redteam: '⚔️',
            blueteam: '🛡️',
            desktopsecurity: '🔒',
            webpentest: '🌐',
            osint: '🔍',
        };
        const icon = modeIcons[this.state.mode];
        const text = `${icon} [${this.state.mode}] >`;
        // Apply color based on mode
        switch (this.state.mode) {
            case 'redteam':
                return chalk.red(text);
            case 'blueteam':
                return chalk.blue(text);
            case 'desktopsecurity':
                return chalk.green(text);
            case 'webpentest':
                return chalk.magenta(text);
            case 'osint':
                return chalk.yellow(text);
            default:
                return chalk.cyan(text);
        }
    }
    showModeStatus() {
        const modelInfo = Object.values(AVAILABLE_MODELS).find(m => m.id === this.state.model);
        const modelName = modelInfo?.name || this.state.model;
        console.log(chalk.dim(`Mode: ${chalk.bold(this.state.mode)} | Model: ${chalk.bold(modelName)}\n`));
    }
    showWelcome() {
        ui.box(`Welcome to ${chalk.bold('Cyber Claude Interactive Session')}!\n\n` +
            `${chalk.bold('🚀 Quick Start Guide:')}\n\n` +
            `${chalk.bold('1. Scan Your System:')}\n` +
            `   ${chalk.cyan('scan')} ${chalk.dim('- Quick security check')}\n` +
            `   ${chalk.cyan('scan full')} ${chalk.dim('- Comprehensive scan with AI analysis')}\n\n` +
            `${chalk.bold('2. Test Websites:')}\n` +
            `   ${chalk.cyan('webscan https://example.com')} ${chalk.dim('- Find vulnerabilities')}\n\n` +
            `${chalk.bold('3. Gather Intel:')}\n` +
            `   ${chalk.cyan('recon example.com')} ${chalk.dim('- OSINT reconnaissance')}\n\n` +
            `${chalk.bold('4. Analyze Network Traffic:')}\n` +
            `   ${chalk.cyan('pcap capture.pcap')} ${chalk.dim('- Parse .pcap files')}\n\n` +
            `${chalk.bold('5. Get Help:')}\n` +
            `   ${chalk.cyan('help')} ${chalk.dim('- Show detailed command guide with examples')}\n\n` +
            `${chalk.bold('6. Chat Naturally:')}\n` +
            `   ${chalk.dim('Just type: ')}${chalk.cyan('How do I secure SSH?')}${chalk.dim(' or ')}${chalk.cyan('Explain XSS attacks')}\n\n` +
            `${chalk.dim('💡 Tip: Type ')}${chalk.cyan('help')}${chalk.dim(' for detailed examples of every command')}\n` +
            `${chalk.dim('💡 Tip: Change modes with ')}${chalk.cyan('mode <name>')}${chalk.dim(' (base, redteam, blueteam, osint, etc.)')}`, '🚀 Interactive Session', 'info');
    }
    async handleCommand(command) {
        const parts = command.toLowerCase().split(' ');
        const cmd = parts[0];
        const args = parts.slice(1);
        // Check for built-in commands first
        switch (cmd) {
            case 'exit':
            case 'quit':
                ui.info('Goodbye! 👋');
                return true;
            case 'help':
                this.showHelp();
                return false;
            case 'clear':
                this.state.agent.clearHistory();
                ui.success('Conversation history cleared');
                return false;
            case 'status':
                this.showStatus();
                return false;
            case 'history':
                this.showHistory();
                return false;
            case 'mode':
                await this.handleModeChange(args);
                return false;
            case 'model':
                await this.handleModelSelect();
                return false;
            case 'scan':
                await this.handleScan(args);
                return false;
            case 'webscan':
                await this.handleWebScan(args);
                return false;
            case 'pcap':
                await this.handlePcap(args);
                return false;
            case 'recon':
                await this.handleRecon(args);
                return false;
            case 'harden':
                await this.handleHarden();
                return false;
            case 'flows':
                await this.handleFlows();
                return false;
            case 'auto':
                await this.handleAuto(command);
                return false;
            default:
                // If not a built-in command, send to agent as chat
                await this.handleChat(command);
                return false;
        }
    }
    showHelp() {
        console.log('\n' + chalk.bold.cyan('═'.repeat(80)));
        console.log(chalk.bold.cyan('                           CYBER CLAUDE - HELP GUIDE'));
        console.log(chalk.bold.cyan('═'.repeat(80)) + '\n');
        // SCANNING COMMANDS
        console.log(chalk.bold.cyan('📊 SCANNING & ANALYSIS COMMANDS\n'));
        console.log(chalk.bold('  scan') + chalk.dim(' - Quick security check of your system'));
        console.log(chalk.dim('    Checks: OS info, running processes, open ports, disk usage'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('scan') + '\n');
        console.log(chalk.bold('  scan full') + chalk.dim(' - Comprehensive system security scan with AI analysis'));
        console.log(chalk.dim('    Analyzes: Everything in quick scan + detailed vulnerability assessment'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('scan full') + '\n');
        console.log(chalk.bold('  scan network') + chalk.dim(' - Analyze active network connections'));
        console.log(chalk.dim('    Shows: Active connections, listening ports, suspicious traffic'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('scan network') + '\n');
        console.log(chalk.bold('  webscan <url>') + chalk.dim(' - Test web application security'));
        console.log(chalk.dim('    Tests: Headers, CSRF, cookies, OWASP Top 10 vulnerabilities'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('webscan https://example.com'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('webscan http://localhost:3000') + '\n');
        console.log(chalk.bold('  recon <target>') + chalk.dim(' - OSINT reconnaissance (passive intelligence gathering)'));
        console.log(chalk.dim('    Gathers: DNS, WHOIS, subdomains, emails, breaches, social media'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('recon example.com') + chalk.dim(' (domain scan)'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('recon johndoe') + chalk.dim(' (username search)'));
        console.log(chalk.yellow('    Options: ') + chalk.dim('--quick (fast), --full (comprehensive), --domain, --person') + '\n');
        console.log(chalk.bold('  pcap <file>') + chalk.dim(' - Analyze network capture files (Wireshark format)'));
        console.log(chalk.dim('    Analyzes: Packets, protocols, conversations, DNS, HTTP, anomalies'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('pcap capture.pcap'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('pcap /path/to/traffic.pcapng') + '\n');
        console.log(chalk.bold('  harden') + chalk.dim(' - Check system hardening and security posture'));
        console.log(chalk.dim('    Checks: Firewall, disk encryption, antivirus, security settings'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('harden') + '\n');
        console.log(chalk.bold('  flows') + chalk.dim(' - Pre-configured workflows for common tasks') + chalk.green(' (Beginner-friendly)'));
        console.log(chalk.dim('    Includes: Quick security check, web audits, OSINT, incident response, CTF, tutorials'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('flows') + '\n');
        console.log(chalk.bold('  auto <task>') + chalk.dim(' - Autonomous task execution with AI planning') + chalk.green(' (NEW!)'));
        console.log(chalk.dim('    AI breaks down tasks into steps and executes autonomously'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('auto scan example.com for vulnerabilities'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('auto gather intel on target-company.com'));
        console.log(chalk.dim('    Options: --mode <mode>, --verbose, --export <file>') + '\n');
        // SESSION CONTROL
        console.log(chalk.bold.cyan('⚙️  SESSION CONTROL\n'));
        console.log(chalk.bold('  mode <mode>') + chalk.dim(' - Switch the AI agent\'s focus and expertise'));
        console.log(chalk.dim('    Available modes (see Agent Modes below for details)'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('mode webpentest'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('mode osint') + '\n');
        console.log(chalk.bold('  model') + chalk.dim(' - Select which AI model to use (Claude or Gemini)'));
        console.log(chalk.dim('    Opens interactive menu to choose from available models'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('model') + '\n');
        console.log(chalk.bold('  status') + chalk.dim(' - Show current session information'));
        console.log(chalk.dim('    Shows: Current mode, model, command count, conversation length'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('status') + '\n');
        console.log(chalk.bold('  clear') + chalk.dim(' - Clear conversation history (fresh start)'));
        console.log(chalk.dim('    Resets the AI\'s memory of previous messages in this session'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('clear') + '\n');
        console.log(chalk.bold('  history') + chalk.dim(' - Show recent commands you\'ve run'));
        console.log(chalk.dim('    Displays last 10 commands from this session'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('history') + '\n');
        // CHAT
        console.log(chalk.bold.cyan('💬 CONVERSATIONAL CHAT\n'));
        console.log(chalk.dim('  Just type naturally to ask questions or get advice:'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('How do I secure my SSH server?'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('Explain what a SQL injection is'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('What ports should I close on my firewall?') + '\n');
        // EXIT
        console.log(chalk.bold.cyan('🚪 EXIT SESSION\n'));
        console.log(chalk.bold('  exit') + chalk.dim(' or ') + chalk.bold('quit') + chalk.dim(' - Close the interactive session'));
        console.log(chalk.yellow('    Example: ') + chalk.cyan('exit') + '\n');
        // AGENT MODES
        console.log(chalk.bold.cyan('═'.repeat(80)));
        console.log(chalk.bold.cyan('🎭 AGENT MODES - Each mode changes how the AI thinks and responds\n'));
        console.log(chalk.cyan('  base ') + chalk.bold('🤖') + chalk.dim(' - General-purpose security assistant'));
        console.log(chalk.dim('    Use for: General questions, learning, mixed tasks'));
        console.log(chalk.dim('    Best for: Beginners, broad security topics\n'));
        console.log(chalk.red('  redteam ') + chalk.bold('⚔️') + chalk.dim(' - Offensive security mindset (attacker perspective)'));
        console.log(chalk.dim('    Use for: Finding vulnerabilities, attack surface analysis'));
        console.log(chalk.dim('    Best for: Penetration testing, security assessments\n'));
        console.log(chalk.blue('  blueteam ') + chalk.bold('🛡️') + chalk.dim(' - Defensive security focus (defender perspective)'));
        console.log(chalk.dim('    Use for: Threat detection, incident response, monitoring'));
        console.log(chalk.dim('    Best for: SOC analysts, defense strategies\n'));
        console.log(chalk.green('  desktopsecurity ') + chalk.bold('🔒') + chalk.dim(' - Personal computer security'));
        console.log(chalk.dim('    Use for: Protecting your laptop/desktop, privacy, malware'));
        console.log(chalk.dim('    Best for: Personal device security, home users\n'));
        console.log(chalk.magenta('  webpentest ') + chalk.bold('🌐') + chalk.dim(' - Web application security testing'));
        console.log(chalk.dim('    Use for: Testing websites, finding web vulnerabilities, CTFs'));
        console.log(chalk.dim('    Best for: Web developers, bug bounty hunters\n'));
        console.log(chalk.yellow('  osint ') + chalk.bold('🔍') + chalk.dim(' - Open Source Intelligence gathering'));
        console.log(chalk.dim('    Use for: Passive reconnaissance, footprinting, information gathering'));
        console.log(chalk.dim('    Best for: Investigating domains, usernames, digital footprints\n'));
        console.log(chalk.bold.cyan('═'.repeat(80)));
        console.log(chalk.dim('💡 Tip: Use ') + chalk.cyan('mode <name>') + chalk.dim(' to switch modes based on your task'));
        console.log(chalk.dim('💡 Tip: Commands can be combined with chat - try ') + chalk.cyan('scan') + chalk.dim(' then ask about results'));
        console.log(chalk.bold.cyan('═'.repeat(80)) + '\n');
    }
    showStatus() {
        const modelInfo = Object.values(AVAILABLE_MODELS).find(m => m.id === this.state.model);
        ui.box(`${chalk.bold('Current Mode:')} ${this.state.mode}\n` +
            `${chalk.bold('Model:')} ${modelInfo?.name || this.state.model}\n` +
            `${chalk.bold('Commands Executed:')} ${this.state.commandHistory.length}\n` +
            `${chalk.bold('Conversation Messages:')} ${this.state.agent.getHistory().length}`, '📊 Session Status', 'info');
    }
    showHistory() {
        if (this.state.commandHistory.length === 0) {
            ui.info('No commands in history yet');
            return;
        }
        console.log(chalk.bold('\n📜 Command History:\n'));
        this.state.commandHistory.slice(-10).forEach((cmd, index) => {
            const num = this.state.commandHistory.length - 10 + index + 1;
            console.log(chalk.dim(`  ${num}.`) + ` ${cmd}`);
        });
        console.log('');
    }
    async handleModeChange(args) {
        if (args.length === 0) {
            ui.info(`Current mode: ${this.state.mode}`);
            ui.info('Available modes: base, redteam, blueteam, desktopsecurity, webpentest, osint');
            return;
        }
        const newMode = args[0];
        const validModes = ['base', 'redteam', 'blueteam', 'desktopsecurity', 'webpentest', 'osint'];
        if (validModes.includes(newMode)) {
            this.state.mode = newMode;
            this.state.agent.setMode(newMode);
            ui.success(`Switched to ${chalk.bold(newMode)} mode`);
            this.showModeStatus();
        }
        else {
            ui.error(`Invalid mode: ${newMode}`);
            ui.info(`Valid modes: ${validModes.join(', ')}`);
        }
    }
    async handleModelSelect() {
        const choices = Object.entries(AVAILABLE_MODELS).map(([key, model]) => ({
            name: `${model.name} ${model.recommended ? chalk.green('(Recommended)') : ''}\n  ${chalk.dim(model.description)}`,
            value: key,
            short: model.name,
        }));
        const { selectedModel } = await inquirer.prompt({
            type: 'list',
            name: 'selectedModel',
            message: 'Select AI model:',
            choices,
            default: 'sonnet-4',
        });
        const model = getModelByKey(selectedModel);
        if (model) {
            this.state.model = model.id;
            this.state.agent = new CyberAgent({
                mode: this.state.mode,
                apiKey: config.anthropicApiKey,
                googleApiKey: config.googleApiKey,
                model: model.id,
            });
            ui.success(`Switched to ${chalk.bold(model.name)}`);
            this.showModeStatus();
        }
    }
    async handleScan(args) {
        const scanType = args[0] || 'quick';
        try {
            if (scanType === 'full') {
                const spinner = ui.spinner('Performing full system scan...');
                const result = await this.scanner.scanSystem();
                spinner.succeed('System scan completed');
                if (result.success) {
                    ui.info('Analyzing with AI...');
                    const aiSpinner = ui.spinner('AI analyzing system security...');
                    const analysis = await this.state.agent.analyze('Perform a comprehensive security analysis of this system. Identify vulnerabilities, security misconfigurations, and potential risks. Provide specific, actionable recommendations.', result.data);
                    aiSpinner.succeed('Analysis complete');
                    console.log('\n' + ui.formatAIResponse(analysis) + '\n');
                }
            }
            else if (scanType === 'network') {
                const spinner = ui.spinner('Scanning network connections...');
                const result = await this.scanner.scanNetwork();
                spinner.succeed('Network scan completed');
                if (result.success) {
                    const aiSpinner = ui.spinner('Analyzing network connections...');
                    const analysis = await this.state.agent.analyze('Analyze these network connections for security concerns. Identify any suspicious connections, unusual ports, or potential security risks.', result.data);
                    aiSpinner.succeed('Analysis complete');
                    console.log('\n' + ui.formatAIResponse(analysis) + '\n');
                }
            }
            else {
                // Quick scan
                const spinner = ui.spinner('Running quick security check...');
                const result = await this.scanner.quickCheck();
                spinner.succeed('Quick check completed');
                if (result.success && result.data.findings) {
                    const scanResult = this.reporter.createScanResult(result.data.findings, new Date());
                    this.reporter.displayReport(scanResult);
                }
            }
        }
        catch (error) {
            ui.error(`Scan failed: ${error}`);
        }
    }
    async handleHarden() {
        try {
            const spinner = ui.spinner('Checking system hardening...');
            const result = await this.hardening.checkHardening();
            spinner.succeed('Hardening check completed');
            if (result.success && result.data.findings) {
                const scanResult = this.reporter.createScanResult(result.data.findings, new Date());
                this.reporter.displayReport(scanResult);
                const aiSpinner = ui.spinner('Getting AI recommendations...');
                const analysis = await this.state.agent.analyze('Based on these hardening check findings, provide prioritized, actionable recommendations to improve system security. Focus on the most critical issues first.', result.data.findings);
                aiSpinner.succeed('Recommendations ready');
                console.log('\n' + ui.formatAIResponse(analysis) + '\n');
            }
        }
        catch (error) {
            ui.error(`Hardening check failed: ${error}`);
        }
    }
    async handleFlows() {
        ui.section('Pre-configured Workflows');
        console.log(chalk.gray('Choose a workflow to get started quickly\n'));
        // Group flows by category
        const grouped = WORKFLOWS.reduce((acc, flow) => {
            if (!acc[flow.category])
                acc[flow.category] = [];
            acc[flow.category].push(flow);
            return acc;
        }, {});
        const choices = [];
        // Create categorized choices
        for (const [category, flows] of Object.entries(grouped)) {
            choices.push(new inquirer.Separator(chalk.bold.cyan(`\n${category.toUpperCase()}:`)));
            flows.forEach(flow => {
                const difficultyEmoji = {
                    beginner: '🟢',
                    intermediate: '🟡',
                    advanced: '🔴',
                }[flow.difficulty];
                choices.push({
                    name: `  ${flow.name} ${difficultyEmoji} ${chalk.gray(`(${flow.estimatedTime})`)}`,
                    value: flow.id,
                    short: flow.name,
                });
            });
        }
        const { selectedFlowId } = await inquirer.prompt([
            {
                type: 'list',
                name: 'selectedFlowId',
                message: 'Select a workflow:',
                choices,
                pageSize: 20,
            },
        ]);
        const selectedFlow = WORKFLOWS.find(f => f.id === selectedFlowId);
        if (!selectedFlow) {
            ui.error('Flow not found');
            return;
        }
        // Show flow details
        ui.section(selectedFlow.name);
        console.log(chalk.gray(selectedFlow.description));
        console.log(chalk.gray(`\nDifficulty: ${selectedFlow.difficulty} | Estimated time: ${selectedFlow.estimatedTime}\n`));
        console.log(chalk.bold('Steps:'));
        selectedFlow.steps.forEach((step, i) => {
            console.log(chalk.gray(`  ${i + 1}. ${step}`));
        });
        console.log('');
        // Confirm execution
        const { confirm } = await inquirer.prompt([
            {
                type: 'confirm',
                name: 'confirm',
                message: 'Ready to start this workflow?',
                default: true,
            },
        ]);
        if (!confirm) {
            console.log(chalk.yellow('Workflow cancelled.\n'));
            return;
        }
        // Execute the workflow
        try {
            await this.executeWorkflow(selectedFlow);
        }
        catch (error) {
            ui.error(`Workflow execution failed: ${error.message}`);
        }
    }
    /**
     * Execute a workflow based on its ID
     */
    async executeWorkflow(flow) {
        switch (flow.id) {
            case 'quick-security-check':
                await this.executeQuickSecurityCheck(flow);
                break;
            case 'website-security-audit':
                await this.executeWebsiteAudit(flow);
                break;
            case 'domain-intel-gathering':
                await this.executeDomainIntel(flow);
                break;
            case 'incident-response-triage':
                await this.executeIncidentTriage(flow);
                break;
            case 'harden-system':
                await this.executeSystemHardening(flow);
                break;
            default:
                console.log(chalk.yellow(`\nWorkflow "${flow.id}" implementation coming soon!`));
                console.log(chalk.gray('Use the standalone command for guided execution:'));
                console.log(chalk.cyan(`  cyber-claude flows\n`));
        }
    }
    /**
     * Quick Security Check Workflow
     */
    async executeQuickSecurityCheck(flow) {
        const spinner = ui.spinner('Scanning system security...').start();
        const scanResultRaw = await this.scanner.quickCheck();
        spinner.succeed('System scan complete');
        const hardeningSpinner = ui.spinner('Checking security settings...').start();
        const hardeningResultRaw = await this.hardening.checkHardening();
        hardeningSpinner.succeed('Security settings analyzed');
        const allFindings = [
            ...(scanResultRaw.success && scanResultRaw.data?.findings ? scanResultRaw.data.findings : []),
            ...(hardeningResultRaw.success && hardeningResultRaw.data?.findings ? hardeningResultRaw.data.findings : [])
        ];
        const scanResult = this.reporter.createScanResult(allFindings, new Date());
        this.reporter.displayReport(scanResult);
        const aiSpinner = ui.spinner('Getting AI security recommendations...').start();
        const analysis = await this.state.agent.analyze('Analyze this security scan and provide actionable recommendations for improving system security. Focus on the most critical issues first.', allFindings);
        aiSpinner.succeed('AI analysis complete');
        console.log('');
        ui.section('🤖 AI Security Recommendations');
        console.log(ui.formatAIResponse(analysis) + '\n');
    }
    /**
     * Website Security Audit Workflow
     */
    async executeWebsiteAudit(flow) {
        const { url } = await inquirer.prompt([
            {
                type: 'input',
                name: 'url',
                message: 'Enter website URL to audit:',
                validate: (input) => input.startsWith('http') || 'Please enter a valid URL (http:// or https://)',
            },
        ]);
        console.log(chalk.yellow('\n⚠️  Make sure you have permission to scan this website!'));
        const { authorized } = await inquirer.prompt([
            {
                type: 'confirm',
                name: 'authorized',
                message: 'Do you have authorization to scan this website?',
                default: false,
            },
        ]);
        if (!authorized) {
            console.log(chalk.red('❌ Authorization required. Scan cancelled.\n'));
            return;
        }
        // Use the existing webscan handler
        await this.handleWebScan([url]);
    }
    /**
     * Domain Intelligence Gathering Workflow
     */
    async executeDomainIntel(flow) {
        const { domain } = await inquirer.prompt([
            {
                type: 'input',
                name: 'domain',
                message: 'Enter domain to investigate:',
                validate: (input) => input.length > 0 || 'Domain is required',
            },
        ]);
        // Use the existing recon handler with --domain flag
        await this.handleRecon([domain, '--domain']);
    }
    /**
     * Incident Response Triage Workflow
     */
    async executeIncidentTriage(flow) {
        const spinner = ui.spinner('Performing incident triage scan...').start();
        const scanResultRaw = await this.scanner.scanSystem();
        spinner.succeed('Full system scan complete');
        const findings = scanResultRaw.success && scanResultRaw.data?.findings ? scanResultRaw.data.findings : [];
        const scanResult = this.reporter.createScanResult(findings, new Date());
        this.reporter.displayReport(scanResult);
        const aiSpinner = ui.spinner('Analyzing for incident indicators...').start();
        const analysis = await this.state.agent.analyze(`Perform incident response triage on this system scan. Look for:
- Suspicious processes or services
- Unusual network connections
- Potential compromise indicators
- Security misconfigurations
- Recommended immediate actions

Provide prioritized findings and actionable next steps.`, findings);
        aiSpinner.succeed('Incident analysis complete');
        console.log('');
        ui.section('🚨 Incident Triage Report');
        console.log(ui.formatAIResponse(analysis) + '\n');
    }
    /**
     * System Hardening Workflow
     */
    async executeSystemHardening(flow) {
        const spinner = ui.spinner('Auditing security configuration...').start();
        const resultsRaw = await this.hardening.checkHardening();
        spinner.succeed('Security audit complete');
        const findings = resultsRaw.success && resultsRaw.data?.findings ? resultsRaw.data.findings : [];
        const scanResult = this.reporter.createScanResult(findings, new Date());
        this.reporter.displayReport(scanResult);
        const aiSpinner = ui.spinner('Generating hardening recommendations...').start();
        const analysis = await this.state.agent.analyze('Based on this security audit, provide step-by-step hardening recommendations. Prioritize by impact and include specific commands or settings to change where applicable.', findings);
        aiSpinner.succeed('Hardening guide generated');
        console.log('');
        ui.section('🔒 System Hardening Guide');
        console.log(ui.formatAIResponse(analysis) + '\n');
    }
    /**
     * Handle autonomous task execution
     */
    async handleAuto(command) {
        // Extract task from command (everything after "auto ")
        const task = command.substring(5).trim(); // Remove "auto " prefix
        if (!task) {
            ui.error('Please provide a task description');
            ui.info('Usage: auto <task description>');
            ui.info('Example: auto scan example.com for vulnerabilities');
            ui.info('Example: auto gather intel on target-company.com');
            return;
        }
        // Import AgenticCore dynamically
        const { AgenticCore } = await import('../agent/core/agentic.js');
        ui.section('🤖 AUTONOMOUS AGENT');
        console.log(chalk.gray(`Task: ${task}`));
        console.log(chalk.gray(`Mode: ${this.state.mode.toUpperCase()}`));
        console.log(chalk.gray(`Model: ${this.state.model}\n`));
        try {
            // Get model info
            const modelInfo = getModelByKey(this.state.model);
            if (!modelInfo) {
                throw new Error(`Invalid model: ${this.state.model}`);
            }
            // Create agentic config using session's current mode and model
            const agenticConfig = {
                apiKey: modelInfo.provider === 'claude' ? config.anthropicApiKey : undefined,
                googleApiKey: modelInfo.provider === 'gemini' ? config.googleApiKey : undefined,
                model: modelInfo.id,
                mode: this.state.mode,
                maxSteps: 20,
                maxDuration: 600000,
                autoApprove: false,
                verbose: true, // Always verbose in interactive mode
            };
            const agent = new AgenticCore(agenticConfig);
            const result = await agent.executeTask(task);
            if (result.success) {
                ui.success('\n✅ Task completed successfully');
                const summary = {
                    stepsCompleted: result.context.completedSteps.length,
                    stepsTotal: result.context.plan.steps.length,
                    findingsCount: result.context.findings.length,
                    errorsCount: result.context.errors.length,
                    duration: (result.duration / 1000).toFixed(1) + 's',
                };
                ui.box(`Steps: ${summary.stepsCompleted}/${summary.stepsTotal}\n` +
                    `Findings: ${summary.findingsCount}\n` +
                    `Errors: ${summary.errorsCount}\n` +
                    `Duration: ${summary.duration}`);
                // Show findings if any
                if (result.context.findings.length > 0) {
                    console.log('\n' + chalk.bold('Security Findings:'));
                    result.context.findings.slice(0, 5).forEach((finding, idx) => {
                        console.log(chalk.gray(`${idx + 1}. [${finding.severity.toUpperCase()}] ${finding.title}`));
                    });
                    if (result.context.findings.length > 5) {
                        console.log(chalk.gray(`  ... and ${result.context.findings.length - 5} more`));
                    }
                }
                console.log('');
            }
            else {
                ui.error('\n❌ Task failed');
                ui.box(`Error: ${result.error}\nDuration: ${(result.duration / 1000).toFixed(1)}s`);
            }
        }
        catch (error) {
            ui.error(`\nAutonomous execution failed: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    async handleChat(message) {
        const spinner = ui.spinner('Thinking...');
        try {
            const response = await this.state.agent.chat(message);
            spinner.stop();
            console.log(chalk.magenta('\nCyber Claude:'));
            console.log(ui.formatAIResponse(response) + '\n');
        }
        catch (error) {
            spinner.fail('Error communicating with agent');
            ui.error(`${error}`);
        }
    }
    async handleWebScan(args) {
        if (args.length === 0) {
            ui.error('Please provide a URL to scan');
            ui.info('Usage: webscan <url>');
            return;
        }
        const url = args[0];
        try {
            console.log('');
            ui.section(`Web Security Scan: ${url}`);
            console.log('');
            // Progress callback
            const onProgress = (message) => {
                console.log(message);
            };
            const result = await this.webScanner.quickScan(url, { onProgress });
            ui.success('✓ Web scan completed\n');
            console.log(`Target: ${result.target.url}`);
            console.log(`Findings: ${result.summary.total}`);
            console.log('');
            let analysis;
            if (result.findings.length > 0) {
                result.findings.slice(0, 5).forEach(finding => {
                    ui.finding(finding.severity, finding.title, finding.description);
                });
                if (result.findings.length > 5) {
                    console.log(`\n... and ${result.findings.length - 5} more findings`);
                }
                // AI Analysis
                const aiSpinner = ui.spinner('🤖 Analyzing with AI...');
                analysis = await this.state.agent.analyze('Analyze these web security findings. Prioritize issues and provide remediation guidance.', { findings: result.findings, target: result.target });
                aiSpinner.succeed('✓ Analysis complete');
                console.log('\n' + ui.formatAIResponse(analysis) + '\n');
            }
            else {
                ui.success('No security issues found!');
            }
            // Save scan results
            const savedPath = await saveScanResults(result, analysis);
            ui.success(`📁 Scan results saved to: ${savedPath}`);
        }
        catch (error) {
            ui.error(`Web scan failed: ${error}`);
        }
    }
    async handlePcap(args) {
        if (args.length === 0) {
            ui.error('Please provide a pcap file to analyze');
            ui.info('Usage: pcap <file.pcap>');
            return;
        }
        const filePath = args[0];
        try {
            console.log('');
            ui.section(`📦 Network Traffic Analysis: ${filePath}`);
            console.log('');
            const spinner = ui.spinner('Parsing pcap file...');
            const analysis = await this.pcapAnalyzer.analyze(filePath, {
                includePackets: false,
                statisticsOnly: false,
            });
            spinner.succeed('Pcap file parsed successfully');
            console.log('');
            // Display summary
            this.pcapReporter.displaySummary(analysis);
            // AI Analysis
            if (analysis.packetCount > 0) {
                const aiSpinner = ui.spinner('🤖 Analyzing network traffic with AI...');
                // Build analysis prompt
                let prompt = `Analyze the following network traffic capture:\n\n`;
                prompt += `File: ${analysis.filename}\n`;
                prompt += `Packets: ${analysis.packetCount.toLocaleString()}\n`;
                prompt += `Duration: ${this.formatDuration(analysis.captureDuration)}\n\n`;
                prompt += `Protocol Distribution:\n`;
                for (const stat of analysis.protocolStats.slice(0, 10)) {
                    prompt += `- ${stat.protocol}: ${stat.packets} packets (${stat.percentage.toFixed(1)}%)\n`;
                }
                prompt += `\n`;
                if (analysis.conversations.length > 0) {
                    prompt += `Top Conversations:\n`;
                    for (const conv of analysis.conversations.slice(0, 5)) {
                        prompt += `- ${conv.protocol} ${conv.sourceAddr}:${conv.sourcePort} ↔ `;
                        prompt += `${conv.destAddr}:${conv.destPort} (${conv.packets} packets)\n`;
                    }
                    prompt += `\n`;
                }
                if (analysis.alerts.length > 0) {
                    prompt += `⚠️ Detected Alerts:\n`;
                    for (const alert of analysis.alerts) {
                        prompt += `- ${alert}\n`;
                    }
                    prompt += `\n`;
                }
                prompt += `Provide a security analysis of this network traffic, highlighting:\n`;
                prompt += `1. Overall traffic patterns and what they indicate\n`;
                prompt += `2. Any suspicious or unusual activity\n`;
                prompt += `3. Security concerns and potential threats\n`;
                prompt += `4. Recommendations for further investigation\n`;
                const aiResponse = await this.state.agent.analyze(prompt, 'network traffic analysis');
                aiSpinner.succeed('✓ Analysis complete');
                console.log('\n' + ui.formatAIResponse(aiResponse) + '\n');
            }
            ui.success('✓ Pcap analysis complete!');
        }
        catch (error) {
            ui.error(`Pcap analysis failed: ${error.message}`);
        }
    }
    async handleRecon(args) {
        if (args.length === 0) {
            ui.error('Please provide a target to investigate');
            ui.info('Usage: recon <domain|username|ip>');
            ui.info('Options: --quick, --full, --domain, --person');
            return;
        }
        const target = args[0];
        // Parse options
        let scanType = 'quick';
        if (args.includes('--full'))
            scanType = 'full';
        else if (args.includes('--domain'))
            scanType = 'domain';
        else if (args.includes('--person'))
            scanType = 'person';
        try {
            console.log('');
            ui.section(`🔍 OSINT Reconnaissance: ${target}`);
            console.log(`Scan Type: ${scanType.toUpperCase()}`);
            console.log('');
            const spinner = ui.spinner('Starting reconnaissance...');
            let result;
            try {
                switch (scanType) {
                    case 'quick':
                        result = await this.osintOrchestrator.quickScan(target);
                        break;
                    case 'full':
                        result = await this.osintOrchestrator.fullScan(target);
                        break;
                    case 'domain':
                        result = await this.osintOrchestrator.domainScan(target);
                        break;
                    case 'person':
                        result = await this.osintOrchestrator.personScan(target);
                        break;
                }
                spinner.succeed('Reconnaissance completed');
            }
            catch (error) {
                spinner.fail('Reconnaissance failed');
                throw error;
            }
            console.log('');
            // Display results
            this.osintReporter.displayResults(result);
            // AI Analysis
            if (result.summary.totalFindings > 0) {
                const aiSpinner = ui.spinner('🤖 Analyzing OSINT findings with AI...');
                // Build analysis prompt
                let prompt = `Analyze the following OSINT reconnaissance results:\n\n`;
                prompt += `Target: ${result.target}\n`;
                prompt += `Findings: ${result.summary.totalFindings}\n`;
                prompt += `Risk Score: ${result.summary.riskScore}/100\n\n`;
                // Add key findings
                if (result.results.dns) {
                    prompt += `DNS Records Found: ${Object.keys(result.results.dns.records).length} types\n`;
                }
                if (result.results.whois) {
                    prompt += `WHOIS: ${result.results.whois.registrar || 'Unknown registrar'}\n`;
                }
                if (result.results.subdomains && result.results.subdomains.total > 0) {
                    prompt += `Subdomains: ${result.results.subdomains.total} discovered\n`;
                }
                if (result.results.emails && result.results.emails.total > 0) {
                    prompt += `Emails: ${result.results.emails.total} addresses found\n`;
                }
                if (result.results.usernames && result.results.usernames.totalFound > 0) {
                    prompt += `Social Media: ${result.results.usernames.totalFound} profiles found\n`;
                }
                if (result.results.breaches && result.results.breaches.length > 0) {
                    prompt += `⚠️ Data Breaches: ${result.results.breaches.length} breach(es) found\n`;
                }
                prompt += `\nProvide:\n`;
                prompt += `1. Security posture assessment\n`;
                prompt += `2. Attack surface analysis\n`;
                prompt += `3. Privacy and exposure concerns\n`;
                prompt += `4. Recommendations for hardening\n`;
                const aiResponse = await this.state.agent.analyze(prompt, result);
                aiSpinner.succeed('✓ Analysis complete');
                console.log('\n' + ui.formatAIResponse(aiResponse) + '\n');
            }
            // Summary
            const riskLevel = result.summary.riskScore > 70
                ? 'HIGH'
                : result.summary.riskScore > 40
                    ? 'MEDIUM'
                    : 'LOW';
            ui.info(`Scan completed: ${result.summary.totalFindings} findings | Risk: ${riskLevel}`);
        }
        catch (error) {
            ui.error(`Reconnaissance failed: ${error.message || error}`);
        }
    }
    formatDuration(ms) {
        if (ms < 1000)
            return `${ms}ms`;
        if (ms < 60000)
            return `${(ms / 1000).toFixed(2)}s`;
        if (ms < 3600000)
            return `${(ms / 60000).toFixed(2)}m`;
        return `${(ms / 3600000).toFixed(2)}h`;
    }
}
//# sourceMappingURL=session.js.map
import inquirer from 'inquirer';
import chalk from 'chalk';
import { ui } from '../utils/ui.js';
import { CyberAgent } from '../agent/core.js';
import { DesktopScanner } from '../agent/tools/scanner.js';
import { HardeningChecker } from '../agent/tools/hardening.js';
import { SecurityReporter } from '../agent/tools/reporter.js';
import { WebScanner } from '../agent/tools/web/WebScanner.js';
import { PcapAnalyzer } from '../agent/tools/PcapAnalyzer.js';
import { PcapReporter } from '../agent/tools/PcapReporter.js';
import { config } from '../utils/config.js';
import { AVAILABLE_MODELS, getModelByKey } from '../utils/models.js';
import { promises as fs } from 'fs';
import * as path from 'path';
/**
 * Save scan results to the /scans directory as markdown
 */
async function saveScanResults(result, analysis) {
    // Create scans directory if it doesn't exist
    const scansDir = path.join(process.cwd(), 'scans');
    await fs.mkdir(scansDir, { recursive: true });
    // Generate filename from hostname and timestamp
    const hostname = result.target.hostname.replace(/[^a-zA-Z0-9.-]/g, '_');
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const filename = `${hostname}_${timestamp}.md`;
    const filepath = path.join(scansDir, filename);
    // Format markdown content
    const markdown = formatScanMarkdown(result, analysis);
    // Write to file
    await fs.writeFile(filepath, markdown, 'utf-8');
    return filepath;
}
/**
 * Format scan results as markdown
 */
function formatScanMarkdown(result, analysis) {
    const lines = [];
    // Header
    lines.push(`# Web Security Scan Report`);
    lines.push(`\n**Target:** ${result.target.url}`);
    lines.push(`**Scan Date:** ${new Date(result.scanTime).toLocaleString()}`);
    lines.push(`**Duration:** ${result.duration}ms`);
    lines.push(`**Protocol:** ${result.target.protocol.toUpperCase()}`);
    if (result.technology?.server) {
        lines.push(`**Server:** ${result.technology.server}`);
    }
    lines.push('');
    // Summary
    lines.push(`## Summary`);
    lines.push('');
    lines.push(`| Severity | Count |`);
    lines.push(`|----------|-------|`);
    lines.push(`| üî¥ Critical | ${result.summary.critical} |`);
    lines.push(`| üü† High | ${result.summary.high} |`);
    lines.push(`| üü° Medium | ${result.summary.medium} |`);
    lines.push(`| üü¢ Low | ${result.summary.low} |`);
    lines.push(`| üîµ Info | ${result.summary.info} |`);
    lines.push(`| **Total** | **${result.summary.total}** |`);
    lines.push('');
    // Findings
    if (result.findings.length > 0) {
        lines.push(`## Findings`);
        lines.push('');
        // Group by severity
        const severityOrder = ['critical', 'high', 'medium', 'low', 'info'];
        for (const severity of severityOrder) {
            const findings = result.findings.filter(f => f.severity === severity);
            if (findings.length === 0)
                continue;
            const emoji = {
                critical: 'üî¥',
                high: 'üü†',
                medium: 'üü°',
                low: 'üü¢',
                info: 'üîµ'
            }[severity];
            lines.push(`### ${emoji} ${severity.toUpperCase()}`);
            lines.push('');
            findings.forEach((finding, index) => {
                lines.push(`#### ${index + 1}. ${finding.title}`);
                lines.push('');
                lines.push(`**Description:** ${finding.description}`);
                lines.push('');
                if (finding.remediation) {
                    lines.push(`**Remediation:** ${finding.remediation}`);
                    lines.push('');
                }
                if (finding.references && finding.references.length > 0) {
                    lines.push(`**References:**`);
                    finding.references.forEach(ref => {
                        lines.push(`- ${ref}`);
                    });
                    lines.push('');
                }
                lines.push(`**Category:** ${finding.category}`);
                lines.push('');
                lines.push('---');
                lines.push('');
            });
        }
    }
    else {
        lines.push(`## Findings`);
        lines.push('');
        lines.push(`‚úÖ No security issues found!`);
        lines.push('');
    }
    // AI Analysis
    if (analysis) {
        lines.push(`## AI Security Analysis`);
        lines.push('');
        lines.push(analysis);
        lines.push('');
    }
    // Footer
    lines.push('---');
    lines.push('');
    lines.push(`*Report generated by Cyber Claude on ${new Date().toLocaleString()}*`);
    return lines.join('\n');
}
export class InteractiveSession {
    state;
    scanner;
    hardening;
    reporter;
    webScanner;
    pcapAnalyzer;
    pcapReporter;
    constructor(initialMode = 'base', model) {
        this.scanner = new DesktopScanner();
        this.hardening = new HardeningChecker();
        this.reporter = new SecurityReporter();
        this.webScanner = new WebScanner();
        this.pcapAnalyzer = new PcapAnalyzer();
        this.pcapReporter = new PcapReporter();
        const selectedModel = model || config.model;
        this.state = {
            agent: new CyberAgent({
                mode: initialMode,
                apiKey: config.anthropicApiKey,
                googleApiKey: config.googleApiKey,
                model: selectedModel,
            }),
            mode: initialMode,
            model: selectedModel,
            commandHistory: [],
        };
    }
    /**
     * Start the interactive session
     */
    async start() {
        ui.clear();
        ui.banner();
        this.showModeStatus();
        this.showWelcome();
        // Main session loop
        while (true) {
            try {
                const prompt = this.getPrompt();
                const { command } = await inquirer.prompt({
                    type: 'input',
                    name: 'command',
                    message: prompt,
                    prefix: '',
                });
                if (!command || command.trim() === '') {
                    continue;
                }
                const trimmedCommand = command.trim();
                this.state.commandHistory.push(trimmedCommand);
                // Handle commands
                const shouldExit = await this.handleCommand(trimmedCommand);
                if (shouldExit) {
                    break;
                }
            }
            catch (error) {
                // User pressed Ctrl+C or error occurred
                console.log('\n');
                ui.info('Exiting session...');
                break;
            }
        }
    }
    getPrompt() {
        const modeIcons = {
            base: 'ü§ñ',
            redteam: '‚öîÔ∏è',
            blueteam: 'üõ°Ô∏è',
            desktopsecurity: 'üîí',
            webpentest: 'üåê',
        };
        const icon = modeIcons[this.state.mode];
        const text = `${icon} [${this.state.mode}] >`;
        // Apply color based on mode
        switch (this.state.mode) {
            case 'redteam':
                return chalk.red(text);
            case 'blueteam':
                return chalk.blue(text);
            case 'desktopsecurity':
                return chalk.green(text);
            case 'webpentest':
                return chalk.magenta(text);
            default:
                return chalk.cyan(text);
        }
    }
    showModeStatus() {
        const modelInfo = Object.values(AVAILABLE_MODELS).find(m => m.id === this.state.model);
        const modelName = modelInfo?.name || this.state.model;
        console.log(chalk.dim(`Mode: ${chalk.bold(this.state.mode)} | Model: ${chalk.bold(modelName)}\n`));
    }
    showWelcome() {
        ui.box(`Welcome to ${chalk.bold('Cyber Claude Interactive Session')}!\n\n` +
            `${chalk.bold('Commands:')}\n` +
            `  ${chalk.cyan('scan')} - Quick security scan\n` +
            `  ${chalk.cyan('scan full')} - Full system scan\n` +
            `  ${chalk.cyan('scan network')} - Network scan\n` +
            `  ${chalk.cyan('webscan <url>')} - Scan web application\n` +
            `  ${chalk.cyan('pcap <file>')} - Analyze network capture file\n` +
            `  ${chalk.cyan('harden')} - Check hardening\n` +
            `  ${chalk.cyan('mode <mode>')} - Change mode (base, redteam, blueteam, desktopsecurity, webpentest)\n` +
            `  ${chalk.cyan('model')} - Select model\n` +
            `  ${chalk.cyan('status')} - Show session status\n` +
            `  ${chalk.cyan('clear')} - Clear conversation history\n` +
            `  ${chalk.cyan('history')} - Show command history\n` +
            `  ${chalk.cyan('help')} - Show help\n` +
            `  ${chalk.cyan('exit')} / ${chalk.cyan('quit')} - Exit session\n\n` +
            `${chalk.dim('Or just type naturally to chat with the agent...')}`, 'üöÄ Interactive Session', 'info');
    }
    async handleCommand(command) {
        const parts = command.toLowerCase().split(' ');
        const cmd = parts[0];
        const args = parts.slice(1);
        // Check for built-in commands first
        switch (cmd) {
            case 'exit':
            case 'quit':
                ui.info('Goodbye! üëã');
                return true;
            case 'help':
                this.showHelp();
                return false;
            case 'clear':
                this.state.agent.clearHistory();
                ui.success('Conversation history cleared');
                return false;
            case 'status':
                this.showStatus();
                return false;
            case 'history':
                this.showHistory();
                return false;
            case 'mode':
                await this.handleModeChange(args);
                return false;
            case 'model':
                await this.handleModelSelect();
                return false;
            case 'scan':
                await this.handleScan(args);
                return false;
            case 'webscan':
                await this.handleWebScan(args);
                return false;
            case 'pcap':
                await this.handlePcap(args);
                return false;
            case 'harden':
                await this.handleHarden();
                return false;
            default:
                // If not a built-in command, send to agent as chat
                await this.handleChat(command);
                return false;
        }
    }
    showHelp() {
        ui.section('Available Commands');
        console.log(chalk.bold.cyan('\nüìä Scanning & Analysis:'));
        console.log(`  ${chalk.cyan('scan')}              Quick security check`);
        console.log(`  ${chalk.cyan('scan full')}         Full system scan with AI analysis`);
        console.log(`  ${chalk.cyan('scan network')}      Analyze network connections`);
        console.log(`  ${chalk.cyan('webscan <url>')}     Scan web application for vulnerabilities`);
        console.log(`  ${chalk.cyan('pcap <file>')}       Analyze network capture file (.pcap)`);
        console.log(`  ${chalk.cyan('harden')}            Check system hardening status`);
        console.log(chalk.bold.cyan('\n‚öôÔ∏è  Session Control:'));
        console.log(`  ${chalk.cyan('mode <mode>')}       Switch agent mode`);
        console.log(`  ${chalk.cyan('model')}             Select AI model`);
        console.log(`  ${chalk.cyan('status')}            Show current session status`);
        console.log(`  ${chalk.cyan('clear')}             Clear conversation history`);
        console.log(`  ${chalk.cyan('history')}           Show command history`);
        console.log(chalk.bold.cyan('\nüí¨ Chat:'));
        console.log(`  ${chalk.dim('Just type naturally to chat with the agent')}`);
        console.log(chalk.bold.cyan('\nüö™ Exit:'));
        console.log(`  ${chalk.cyan('exit')} / ${chalk.cyan('quit')}     Exit session\n`);
        console.log(chalk.bold('Agent Modes:'));
        console.log(`  ${chalk.cyan('base')}              General security assistant`);
        console.log(`  ${chalk.red('redteam')}           Offensive security perspective`);
        console.log(`  ${chalk.blue('blueteam')}          Defensive security focus`);
        console.log(`  ${chalk.green('desktopsecurity')}   Personal computer security`);
        console.log(`  ${chalk.magenta('webpentest')}        Web application security testing\n`);
    }
    showStatus() {
        const modelInfo = Object.values(AVAILABLE_MODELS).find(m => m.id === this.state.model);
        ui.box(`${chalk.bold('Current Mode:')} ${this.state.mode}\n` +
            `${chalk.bold('Model:')} ${modelInfo?.name || this.state.model}\n` +
            `${chalk.bold('Commands Executed:')} ${this.state.commandHistory.length}\n` +
            `${chalk.bold('Conversation Messages:')} ${this.state.agent.getHistory().length}`, 'üìä Session Status', 'info');
    }
    showHistory() {
        if (this.state.commandHistory.length === 0) {
            ui.info('No commands in history yet');
            return;
        }
        console.log(chalk.bold('\nüìú Command History:\n'));
        this.state.commandHistory.slice(-10).forEach((cmd, index) => {
            const num = this.state.commandHistory.length - 10 + index + 1;
            console.log(chalk.dim(`  ${num}.`) + ` ${cmd}`);
        });
        console.log('');
    }
    async handleModeChange(args) {
        if (args.length === 0) {
            ui.info(`Current mode: ${this.state.mode}`);
            ui.info('Available modes: base, redteam, blueteam, desktopsecurity, webpentest');
            return;
        }
        const newMode = args[0];
        const validModes = ['base', 'redteam', 'blueteam', 'desktopsecurity', 'webpentest'];
        if (validModes.includes(newMode)) {
            this.state.mode = newMode;
            this.state.agent.setMode(newMode);
            ui.success(`Switched to ${chalk.bold(newMode)} mode`);
            this.showModeStatus();
        }
        else {
            ui.error(`Invalid mode: ${newMode}`);
            ui.info(`Valid modes: ${validModes.join(', ')}`);
        }
    }
    async handleModelSelect() {
        const choices = Object.entries(AVAILABLE_MODELS).map(([key, model]) => ({
            name: `${model.name} ${model.recommended ? chalk.green('(Recommended)') : ''}\n  ${chalk.dim(model.description)}`,
            value: key,
            short: model.name,
        }));
        const { selectedModel } = await inquirer.prompt({
            type: 'list',
            name: 'selectedModel',
            message: 'Select AI model:',
            choices,
            default: 'sonnet-4',
        });
        const model = getModelByKey(selectedModel);
        if (model) {
            this.state.model = model.id;
            this.state.agent = new CyberAgent({
                mode: this.state.mode,
                apiKey: config.anthropicApiKey,
                googleApiKey: config.googleApiKey,
                model: model.id,
            });
            ui.success(`Switched to ${chalk.bold(model.name)}`);
            this.showModeStatus();
        }
    }
    async handleScan(args) {
        const scanType = args[0] || 'quick';
        try {
            if (scanType === 'full') {
                const spinner = ui.spinner('Performing full system scan...');
                const result = await this.scanner.scanSystem();
                spinner.succeed('System scan completed');
                if (result.success) {
                    ui.info('Analyzing with AI...');
                    const aiSpinner = ui.spinner('AI analyzing system security...');
                    const analysis = await this.state.agent.analyze('Perform a comprehensive security analysis of this system. Identify vulnerabilities, security misconfigurations, and potential risks. Provide specific, actionable recommendations.', result.data);
                    aiSpinner.succeed('Analysis complete');
                    console.log('\n' + ui.formatAIResponse(analysis) + '\n');
                }
            }
            else if (scanType === 'network') {
                const spinner = ui.spinner('Scanning network connections...');
                const result = await this.scanner.scanNetwork();
                spinner.succeed('Network scan completed');
                if (result.success) {
                    const aiSpinner = ui.spinner('Analyzing network connections...');
                    const analysis = await this.state.agent.analyze('Analyze these network connections for security concerns. Identify any suspicious connections, unusual ports, or potential security risks.', result.data);
                    aiSpinner.succeed('Analysis complete');
                    console.log('\n' + ui.formatAIResponse(analysis) + '\n');
                }
            }
            else {
                // Quick scan
                const spinner = ui.spinner('Running quick security check...');
                const result = await this.scanner.quickCheck();
                spinner.succeed('Quick check completed');
                if (result.success && result.data.findings) {
                    const scanResult = this.reporter.createScanResult(result.data.findings, new Date());
                    this.reporter.displayReport(scanResult);
                }
            }
        }
        catch (error) {
            ui.error(`Scan failed: ${error}`);
        }
    }
    async handleHarden() {
        try {
            const spinner = ui.spinner('Checking system hardening...');
            const result = await this.hardening.checkHardening();
            spinner.succeed('Hardening check completed');
            if (result.success && result.data.findings) {
                const scanResult = this.reporter.createScanResult(result.data.findings, new Date());
                this.reporter.displayReport(scanResult);
                const aiSpinner = ui.spinner('Getting AI recommendations...');
                const analysis = await this.state.agent.analyze('Based on these hardening check findings, provide prioritized, actionable recommendations to improve system security. Focus on the most critical issues first.', result.data.findings);
                aiSpinner.succeed('Recommendations ready');
                console.log('\n' + ui.formatAIResponse(analysis) + '\n');
            }
        }
        catch (error) {
            ui.error(`Hardening check failed: ${error}`);
        }
    }
    async handleChat(message) {
        const spinner = ui.spinner('Thinking...');
        try {
            const response = await this.state.agent.chat(message);
            spinner.stop();
            console.log(chalk.magenta('\nCyber Claude:'));
            console.log(ui.formatAIResponse(response) + '\n');
        }
        catch (error) {
            spinner.fail('Error communicating with agent');
            ui.error(`${error}`);
        }
    }
    async handleWebScan(args) {
        if (args.length === 0) {
            ui.error('Please provide a URL to scan');
            ui.info('Usage: webscan <url>');
            return;
        }
        const url = args[0];
        try {
            console.log('');
            ui.section(`Web Security Scan: ${url}`);
            console.log('');
            // Progress callback
            const onProgress = (message) => {
                console.log(message);
            };
            const result = await this.webScanner.quickScan(url, { onProgress });
            ui.success('‚úì Web scan completed\n');
            console.log(`Target: ${result.target.url}`);
            console.log(`Findings: ${result.summary.total}`);
            console.log('');
            let analysis;
            if (result.findings.length > 0) {
                result.findings.slice(0, 5).forEach(finding => {
                    ui.finding(finding.severity, finding.title, finding.description);
                });
                if (result.findings.length > 5) {
                    console.log(`\n... and ${result.findings.length - 5} more findings`);
                }
                // AI Analysis
                const aiSpinner = ui.spinner('ü§ñ Analyzing with AI...');
                analysis = await this.state.agent.analyze('Analyze these web security findings. Prioritize issues and provide remediation guidance.', { findings: result.findings, target: result.target });
                aiSpinner.succeed('‚úì Analysis complete');
                console.log('\n' + ui.formatAIResponse(analysis) + '\n');
            }
            else {
                ui.success('No security issues found!');
            }
            // Save scan results
            const savedPath = await saveScanResults(result, analysis);
            ui.success(`üìÅ Scan results saved to: ${savedPath}`);
        }
        catch (error) {
            ui.error(`Web scan failed: ${error}`);
        }
    }
    async handlePcap(args) {
        if (args.length === 0) {
            ui.error('Please provide a pcap file to analyze');
            ui.info('Usage: pcap <file.pcap>');
            return;
        }
        const filePath = args[0];
        try {
            console.log('');
            ui.section(`üì¶ Network Traffic Analysis: ${filePath}`);
            console.log('');
            const spinner = ui.spinner('Parsing pcap file...');
            const analysis = await this.pcapAnalyzer.analyze(filePath, {
                includePackets: false,
                statisticsOnly: false,
            });
            spinner.succeed('Pcap file parsed successfully');
            console.log('');
            // Display summary
            this.pcapReporter.displaySummary(analysis);
            // AI Analysis
            if (analysis.packetCount > 0) {
                const aiSpinner = ui.spinner('ü§ñ Analyzing network traffic with AI...');
                // Build analysis prompt
                let prompt = `Analyze the following network traffic capture:\n\n`;
                prompt += `File: ${analysis.filename}\n`;
                prompt += `Packets: ${analysis.packetCount.toLocaleString()}\n`;
                prompt += `Duration: ${this.formatDuration(analysis.captureDuration)}\n\n`;
                prompt += `Protocol Distribution:\n`;
                for (const stat of analysis.protocolStats.slice(0, 10)) {
                    prompt += `- ${stat.protocol}: ${stat.packets} packets (${stat.percentage.toFixed(1)}%)\n`;
                }
                prompt += `\n`;
                if (analysis.conversations.length > 0) {
                    prompt += `Top Conversations:\n`;
                    for (const conv of analysis.conversations.slice(0, 5)) {
                        prompt += `- ${conv.protocol} ${conv.sourceAddr}:${conv.sourcePort} ‚Üî `;
                        prompt += `${conv.destAddr}:${conv.destPort} (${conv.packets} packets)\n`;
                    }
                    prompt += `\n`;
                }
                if (analysis.alerts.length > 0) {
                    prompt += `‚ö†Ô∏è Detected Alerts:\n`;
                    for (const alert of analysis.alerts) {
                        prompt += `- ${alert}\n`;
                    }
                    prompt += `\n`;
                }
                prompt += `Provide a security analysis of this network traffic, highlighting:\n`;
                prompt += `1. Overall traffic patterns and what they indicate\n`;
                prompt += `2. Any suspicious or unusual activity\n`;
                prompt += `3. Security concerns and potential threats\n`;
                prompt += `4. Recommendations for further investigation\n`;
                const aiResponse = await this.state.agent.analyze(prompt, 'network traffic analysis');
                aiSpinner.succeed('‚úì Analysis complete');
                console.log('\n' + ui.formatAIResponse(aiResponse) + '\n');
            }
            ui.success('‚úì Pcap analysis complete!');
        }
        catch (error) {
            ui.error(`Pcap analysis failed: ${error.message}`);
        }
    }
    formatDuration(ms) {
        if (ms < 1000)
            return `${ms}ms`;
        if (ms < 60000)
            return `${(ms / 1000).toFixed(2)}s`;
        if (ms < 3600000)
            return `${(ms / 60000).toFixed(2)}m`;
        return `${(ms / 3600000).toFixed(2)}h`;
    }
}
//# sourceMappingURL=session.js.map